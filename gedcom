#!/usr/bin/env perl

# gedcom - produce data from a gedcom file

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015-2018, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# FIXME: -a Goes through the entire file once for each day without remembering
#	anything
# TODO: add option to print in generations order rather than date order.
# TODO: write a post-processor to sort errors by type
# TODO: add warning for 'bet 2000 and 1999'
# TODO: note if a child was orphaned by both parents dying before they were 16

use strict;
use warnings;
use autodie qw(:all);
# use diagnostics;
# use warnings::unused;

BEGIN {
	eval 'use Geo::Coder::List';
	if($@) {
		system('cpan -i Gedcom Genealogy::Gedcom::Date Date::Parse Geo::Coder::List Geo::Coder::Free IPC::System::Simple Geo::Coder::Ovi');
		system('cpan -i Geo::Coder::RandMcnally Geo::Coder::US::Census Geo::Coder::OSM Geo::Coder::XYZ Geo::Coder::CA Geo::Coder::Postcodes');
		system('cpan -i Geo::Coder::GooglePlaces Geo::Coder::Bing Geo::GeoNames F/FR/FRIFFIN/Geo-Coder-PlaceFinder-0.1.tar.gz');
		system('cpan -i Lingua::EN::NameCase Lingua::EN::Numbers::Ordinate Lingua::EN::ABC Lingua::EN::Inflect DateTime::Format::Natural');
		system('cpan -i DateTime::Format::Genealogy URI::Find::Schemeless Sort::Key::DateTime Text::Names::GB Data::Fetch HTTP::Cache::Transparent Geo::Coder::DataScienceToolkit');
	}
}

use Gedcom;
use Genealogy::Gedcom::Date 2.01;
use Date::Parse;	# For strptime
use Getopt::Std;
use Geo::Coder::List 0.15;
use Geo::Coder::Free 0.10;	# 0.11 really
use Geo::Coder::Ovi;
use Geo::Coder::RandMcnally;
use Geo::Coder::US::Census;
use Geo::Coder::OSM;
use Geo::Coder::XYZ;
use Geo::Coder::CA;
use Geo::Coder::Postcodes;
use Geo::Coder::GooglePlaces;
use Geo::Coder::Bing;
use Geo::Coder::DataScienceToolkit;
use Geo::GeoNames;
use Geo::Coder::PlaceFinder;
# use Geo::Coder::GeocodeFarm;
use Term::ANSIColor;
use Lingua::EN::NameCase;
use Lingua::EN::NameParse;
use Lingua::EN::Numbers::Ordinate;
use Lingua::EN::ABC;
use Lingua::EN::Inflect;
# use Lingua::EN::AddressParse;
use Geo::StreetAddress::US;
# use Geo::Parser::Text;
use Locale::US;
use DateTime::Duration;
use DateTime::Format::Natural;
use DateTime::Format::Genealogy;
use Text::Wrap;
use LWP::Simple;
use LWP::UserAgent::Throttled;
use LWP::ConnCache;
use URI;
use URI::Find::Schemeless;
use Sort::Key::DateTime;
use Text::Names::GB;
use Memoize;
use Data::Fetch;
use Text::Soundex;
use List::Util;
use Locale::Object::Country;
use Module::Load;
use Config::Auto;

no lib '.';

my %opts;
getopts('aAbB:cCdDfGh:Hm:lLp:stTwWvy:', \%opts);
die "Usage: $0 [ -a ] [ -A ] [ -b ] [ -B book.pdf ] [ -c ] [ -C ] [ -d ] [ -D ] [ -f ] [ -G ] [ -h home-person-name ] [ -H [ -L ] [ -m month ] [ -y year ] ] [ -l ] [ -p person-to-print ] [ -s ] [ -t ][ -T ] [ -w [ -W ] ] filename [ filename2 ]\n" unless($ARGV[0]);

my $me;
my @myancestors;
my @mydescendents;
my %warned;
my %printed;
my %places;
my %all_places;

my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);
my $ged2;
if($ARGV[1]) {
	$ged2 = Gedcom->new(gedcom_file => $ARGV[1], read_only => 1);
}

my $nameparser = Lingua::EN::NameParse->new(extended_titles => 1, initials => 1);
if($opts{h}) {
	my @rc = $ged->get_individual($opts{h});
	if(scalar(@rc) == 0) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	} elsif(scalar(@rc) == 1) {
		$me = $rc[0];
	} else {
		my $i = 0;
		print join("\n", map { $i++; "$i: " . $_->as_string({ include_years => 1, middle_names => 1 }) } @rc),
			"\nMore than one $opts{h} found - choose a line number: ";
		$i = <STDIN>;
		chomp $i;
		$me = $rc[$i - 1];
		die "Incorrect line number" unless($me);
	}
}

if($opts{'f'}) {
	$opts{'w'} = 1;
}

die '-w option needs -d option' if($opts{'w'} && !$opts{'d'});

my $browser;
my $us;
my $birth_country;
my $grave_modules;
if($opts{'w'} || $opts{'B'}) {
	$browser = LWP::UserAgent::Throttled->new(agent => 'gedcom', keep_alive => 1);
	$browser->env_proxy(1);
	$browser->conn_cache->total_capacity(undef);

	# Cache calls to openstreetmap etc.
	require File::Spec;
	File::Spec->import();

	require HTTP::Cache::Transparent;
	HTTP::Cache::Transparent->import();

	if($opts{'B'}) {
		require File::Temp;
		File::Temp->import();

		require Image::Resize;
		Image::Resize->import();

		require String::ProgressBar;
		String::ProgressBar->import();
	}

	my $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', 'http-cache-transparent');

	HTTP::Cache::Transparent::init({
		BasePath => $cachedir,
		Verbose => $opts{'v'} ? 1 : 0,
		NoUpdate => 60 * 60 * 24,
		MaxAge => 30 * 24
	}) || die "$0: $cachedir: $!";

	if($opts{'w'}) {
		# If you have a locally written module to look up entries, list them in gedcom.config, otherwise use
		# WWW::Scrape::FindaGrave
		my $config;

		eval { $config = Config::Auto::parse() };

		if($config && $config->{'grave_modules'}) {
			$grave_modules = $config->{'grave_modules'};

			if(ref($grave_modules)) {
				foreach my $module(@{$grave_modules}) {
					autoload $module;
				}
			} else {
				autoload $grave_modules;
			}
		} else {
			# require WWW::Scrape::FindaGrave;
			# WWW::Scrape::FindaGrave->import();
		}
		# if(!$ged->validate() && $opts{'f'}) {
			# die "$ARGV[0] is not a valid gedcom file";
		# }

		require Locale::US;
		Locale::US->import();

		$us = Locale::US->new();
	}
}

my %all_dates;	# Maps dates to the hashref from Genealogy::Gedcom::Date

my $date_parser = Genealogy::Gedcom::Date->new();
my $dfn = DateTime::Format::Natural->new();
my $dfg = DateTime::Format::Genealogy->new();

my $geocoder = Geo::Coder::List->new();
# my $textgeocoder;
my $textgeocoder;

if(my $oa = $ENV{'OPENADDR_HOME'}) {
	$textgeocoder = Geo::Coder::Free->new(openaddr => $oa);
	# $geocoder->push({ regex => qr/,[\w\s]+,[\w\s]+$/, geocoder => $textgeocoder });
		$geocoder->push({ regex => qr/,\s*(USA|US|United States|Canada|Australia)\s*$/, geocoder => $textgeocoder })
			->push({ regex => qr/^([\w\s]+,)?\s*[\w\s]+,\s*[\w\s]+\s*$/, geocoder => $textgeocoder });
} else {
	$textgeocoder = Geo::Coder::Free->new();
	$geocoder->push({ regex => qr/^[\w\s\-]+?,[\w\s]+,[\w\s]+?$/, geocoder => $textgeocoder });
}

# E.g. 'Nebraska, USA'
$geocoder->push({ regex => qr/[\w\s]+?,\s*(UK|England|Canada|USA|US|United States)$/i, geocoder => $textgeocoder });

if(my $username = $ENV{'GEONAMES_USER'}) {
	$geocoder->push(Geo::GeoNames->new(username => $username));
}

$geocoder->push({ regex => qr/(UK|United Kingdom|England|USA|US|United States|Wales)$/i, geocoder => Geo::Coder::DataScienceToolkit->new() })
	->push({ regex => qr/^\d.+?,.+?,\s*(USA|US|United States)$/i, geocoder => Geo::Coder::US::Census->new() })
	->push({ limit => 100, regex => qr/(Canada|USA|United States)$/, geocoder => Geo::Coder::CA->new() })
	->push({ regex => qr/(USA|US|United States)$/i, geocoder => Geo::Coder::RandMcnally->new() })
	->push({ regex => qr/^[\w\s-]+,\s*[\w\s]+,\s*(UK|United Kingdom|England|Wales)$/i, geocoder => Geo::Coder::Postcodes->new() })
	->push(Geo::Coder::OSM->new())
	->push(Geo::Coder::Ovi->new())
	->push(Geo::Coder::XYZ->new());
	# ->push(Geo::Coder::GeocodeFarm->new());	# Needs GT#1 to be fixed

if(my $key = $ENV{'GMAP_KEY'}) {
	$geocoder->push({ limit => 200, geocoder => Geo::Coder::GooglePlaces->new(key => $key, api_key => $key) });
}
if(my $key = $ENV{BMAP_KEY}) {
	$geocoder->push(Geo::Coder::Bing->new(key => $key));
}

if($browser) {
	$browser->throttle({
		'nominatim.openstreetmap.org' => 1,
		'geocode.xyz' => 2,
		'geocoder.ca' => 1,
		'api.postcodes.io' => 1,
		'where.desktop.mos.svc.ovi.com' => 1,
		'geocoding.geo.census.gov' => 1,
		'a2ageo.rmservers.com' => 1,
		'dev.virtualearth.net' => 1,	# Bing
		'api.geonames.org' => 1,
		'yboss.yahooapis.com' => 1,	# Geo::Coder::PlaceFinder
	});
	# G::C::GooglePlaces
	$browser->throttle({ 'maps.googleapis.com' => 0.1 }) unless($ENV{GMAP_KEY});
	$browser->ssl_opts(verify_hostname => 0);	# prevent "Can't connect to geocode.xyz:443 (certificate verify failed)"
	$geocoder->ua($browser);

	# $textgeocoder = Geo::Parser::Text->new('https://geocoder.ca');
	# $textgeocoder = Geo::Parser::Text->new('https://geocode.xyz');

	# Geo::Coder::PlaceFinder doesn't support the ua() method
	if((my $ckey = $ENV{'YAHOO_CONSUMER'}) && (my $skey = $ENV{'YAHOO_SECRET'})) {
		$geocoder->push(Geo::Coder::PlaceFinder->new(consumer_key => $ckey, secret_key => $skey, ua => $browser));
	}
}

my $oneday = DateTime::Duration->new(days => 1);
my $tenmonths = DateTime::Duration->new(months => 10);
my $sixteenyears = DateTime::Duration->new(years => 16);
my $fortyyears = DateTime::Duration->new(years => 40);
my $fetcher;
my $pdf;
my $pdfpage;
my @tmpfiles;
my $pr;

my @everyone;
# Don't get everyone if we're after a specific person, or we're producing a book of a person
unless($opts{'p'} || (($opts{'A'} || $opts{'G'}) && $opts{'B'} && $opts{'h'})) {
	@everyone = $ged->individuals();
}

if($opts{'c'} && !$opts{'d'}) {
	die '-c only makes sense with the -d option';
}
if($opts{'m'} && !$opts{'H'}) {
	die '-m only makes sense with the -H option';
}
if($opts{'y'} && !$opts{'H'}) {
	die '-y only makes sense with the -H option';
}
if($opts{'L'} && !$opts{'H'}) {
	die '-L only makes sense with the -H option';
}
if($opts{'W'} && !$opts{'w'}) {
	die '-W only makes sense with the -w option';
}
if($opts{'A'} && $opts{'G'}) {
	die '-A doesn\'t make sense with the -G option';
}

if($opts{'B'}) {
	require PDF::API2;
	PDF::API2->import();

	$pdf = PDF::API2->new(-file => $opts{'B'});
	if(defined($ENV{'LANG'}) &&($ENV{'LANG'} =~ /^en_US/)) {
		$pdf->mediabox('Letter');
		$Text::Wrap::columns = 105;
	} else {
		$pdf->mediabox('A4');
		$Text::Wrap::columns = 110;
	}
	$opts{'A'} = 1 unless($opts{'G'});
} elsif($opts{'s'}) {
	die '-s only makes sense with the -B option';
}

if($opts{'A'} || $opts{'G'}) {
	$opts{'a'} = 1;
}
if($opts{'T'}) {
	require String::ProgressBar;
	String::ProgressBar->import();
	$pr = String::ProgressBar->new(max => scalar(@everyone), length => 60);
	$opts{'A'} = $opts{'a'} = $opts{'d'} = 1;
}

if($opts{'B'} || $opts{'a'}) {
	memoize('Gedcom::Individual::as_string');
	memoize('stepsabove');
	memoize('normalize_name');	# Speeds up sort with -B a lot
	memoize('date_to_datetime');
}

my $dot;
if($opts{'B'}) {
	if(-x '/usr/bin/dot') {
		$dot = '/usr/bin/dot';
	} elsif(-x '/usr/local/bin/dot') {
		$dot = '/usr/local/bin/dot';
	} elsif(-x '/sw/bin/dot') {
		$dot = '/sw/bin/dot';
	}

	if(!defined($dot)) {
		if($opts{'f'}) {
			die 'Graphviz not found, no family trees';
		}
		if($opts{'w'}) {
			red_warning(warning => 'Graphviz not found, no family trees');
		}
	} else {
		require Image::Magick::Thumbnail;
		Image::Magick::Thumbnail->import();
		print "Using $dot\n" if($opts{'v'});
	}
}

if($opts{'H'}) {
	die '-H only makes sense with the -d option' unless($opts{'d'});
	die '-a doesn\'t make sense with the -H option' if($opts{'a'});
	die '-h doesn\'t make sense with the -H option' if($opts{'h'});
	die '-p doesn\'t make sense with the -H option' if($opts{'p'});
	die '-H doesn\'t support citations' if($opts{'c'});

	require HTML::Table;

	my $dtl = DateTime::Locale->load($ENV{'LANG'});

	my @dow = @{$dtl->day_format_wide()};
	if($dtl->first_day_of_week() eq 7) {
		# e.g. US
		unshift @dow, pop @dow;
	}
	my $table = HTML::Table->new(-border => 1, -padding => 5, -head => \@dow);
	print '<html><head><title>Gedcom Calendar</title></head><body><font size="2">',
		'<style>table { empty-cells: show; }</style>';

	foreach my $day(0..6) {
		# $table->setCell(1, $day + 1, $days[$day]);
		$table->setColWidth($day, '14.29%');
		$table->setColVAlign($day, 'top');
	}

	my $month;
	if($opts{'m'}) {
		$month = $opts{'m'};
		if(($month =~ /\D/) || ($month < 1) || ($month > 12)) {
			die "$0: invalid month number $month";
		}
		$month--;
	} else {
		$month = (localtime)[4]; # 0..11
	}

	my $dt = DateTime->today();
	my $year;
	if($opts{'y'}) {
		$year = $opts{'y'};
		if($year !~ /\d{3,4}/) {
			die "$0: invalid year number $month";
		}
	} else {
		$year = $dt->year();
	}

	$dt = DateTime->last_day_of_month(month => $month + 1, year => $year);
	$dt->subtract(months => 1);
	$dt->add(days => 1);
	my $column = $dt->day_of_week();
	if($dtl->first_day_of_week() eq 7) {
		$column++;
		if($column == 8) {
			$column = 1;
		}
	}

	foreach my $column(1..7) {
		$table->setCell(2, $column, '&nbsp;');
	}

	my $row = 2;
	while($dt->month() == $month + 1) {
		$table->setCellVAlign($row, $column, 'top');
		$table->setCell($row, $column, '<font size="1">' . $dt->day() . '</font>');
		$dt->add(days => 1);
		if($dt->day() == 1) {
			last;
		}
		if($column == 7) {
			$row++;
			foreach my $column(1..7) {
				$table->setCell($row, $column, '&nbsp;');
			}
			$column = 1;
		} else {
			$column++;
		}
	}

	print "<center><h2>", @{$dtl->month_format_wide()}[$month], " $year</h2></center>";

	foreach my $day(1..28) {
		generate(day => $day, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
	}
	if($month == 1) {
		# February
		if(($year % 100) == 0) {
			if(($year % 400) == 0) {
				generate(day => 29, month => $month, everyone => \@everyone);
			}
		} elsif(($year % 4) == 0) {
			generate(day => 29, month => $month, everyone => \@everyone);
		}
	} else {
		generate(day => 29, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		generate(day => 30, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
			generate(day => 31, month => $month, year => $year, everyone => \@everyone, table => $table, dtl => $dtl);
		}
	}
	print '<center>';
	$table->print();
	print '</center></font></body></html>';
} elsif($opts{a}) {
	die '-b and -a should not be given together' if($opts{'b'});
	die '-D and -a should not be given together' if($opts{'D'});
	die '-p and -a should not be given together' if($opts{'p'});

	if($opts{'A'} || $opts{'G'}) {
		if($opts{'B'}) {
			if($opts{'h'}) {
				my $page = $pdf->page();

				my $font = $pdf->corefont('Times-Bold');

				my $text = $page->text();
				$text->font($font, 28);
				$text->translate(300, 600);
				my $surname;
				if($opts{'s'}) {
					if($opts{'h'} =~ /\s*([A-Z]+?)$/i) {
						$surname = $1;
					} else {
						$surname = $opts{'h'};
					}
					$text->text_center("The Surname Book of $surname");
				} else {
					$text->text_center('The Family Tree of');
					$text->translate(300, 525);
					$text->text_center(normalize_name($opts{'h'}));
				}
				my %args;
				if(defined($ENV{'TZ'}) && ($ENV{'TZ'} !~ /^\//)) {
					$args{'time_zone'} = $ENV{'TZ'};
				} else {
					$args{'time_zone'} = DateTime::TimeZone->new(name => 'local');
				}
				my $dt = DateTime->today(%args);
				my $dtl = DateTime::Locale->load($ENV{'LANG'});
				if($opts{'s'}) {
					$text->translate(300, 525);
				} else {
					$text->translate(300, 450);
				}
				$text->text_center('Compiled on ' .
					$dt->day() . ' ' .
					@{$dtl->month_format_wide()}[$dt->month - 1] . ' ' .
					$dt->year()
				);
				if($opts{'s'} && !$opts{'G'}) {
					$text->translate(300, 450);
					if(is_alive(person => $me)) {
						$text->text_center('for ' . normalize_name($opts{'h'}));
					} else {
						my $n = normalize_name($me->as_string(include_years => 1));
						$n =~ s/\sC(\d)/ c$1/;
						$text->text_center("for $n");
					}
				}
				$text->font($font, 12);
				$text->translate(220, 40);
				$text->text('Produced by gedcom - https://github.com/nigelhorne/gedcom');
				$text->textend();

				# my $gfx = $page->gfx();
				# my $image = $pdf->image_png('/Users/njh/src/njh/ged2site/dynamic-site/images/printer.png');
				# $gfx->image($image, 100, 100);
				# $image->height(32);
				# $image->width(32);

				@everyone = ($me, ancestors($me), descendents($me));
				my @siblings = ($me->siblings(), $me->half_siblings());
				foreach my $sibling(@siblings) {
					# print $sibling->as_string(), "\n";
					@everyone = descendents($sibling, \@everyone);
				}
				@everyone = (@everyone, @siblings);

				if($surname) {
					my $nara = soundex_nara($surname);
					# @everyone = grep { $_->as_string() =~ /.*$surname$/i } @everyone;
					@everyone = grep { ($_->as_string() =~ /$surname$/i) || ($_->surname() && (soundex_nara($_->surname()) eq $nara)) } @everyone;
				}
			} elsif($opts{'s'}) {
				die '-s and -h must be given together';
			}
		}
		$fetcher = Data::Fetch->new();

		$pr = String::ProgressBar->new(max => scalar(@everyone), length => 60);

		if($opts{'G'}) {
			if($me->father() || $me->mother()) {
				die 'A generations book (-B and -G) must have the -h person at the top of the tree';
			}
			# Put a family tree of the first few generations on page 2
			# Fit as many as we can until the text is going to become too small
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			my $png = '/tmp/njh.png';	# FIXME

			my $maxrank = 2;
			while(count_descendents_at_level($me, $maxrank + 1) <= 10) {
				$maxrank++;
			}

			if(open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/usr/bin/tee foo')) {
				print $fout 'digraph family {',
					'rotate = 90 subgraph main { rank="0"; ';
				print_graphviz({ person => $me, fout => $fout, format => 'dynamic' });
				print_graphviz_generation({ person => $me, fout => $fout, format => 'dynamic', rank => 0, maxrank => $maxrank + 1 });
				print $fout '}}';
				close $fout;

				my $image;
				my $resize = Image::Resize->new($png);
				my $width = $resize->width();
				my $height = $resize->height();
				my $gd;
				if($height > 715) {
					my $newwidth = $width * (715 / $height);
					my $newheight;
					if($newwidth > 550) {
						$newheight = $height * (550 / $width);
						$gd = $resize->resize(550, $newheight);
					} else {
						$gd = $resize->resize($newwidth, 715);
					}
				} elsif($width > 550) {
					my $newheight = $height * (550 / $width);
					$gd = $resize->resize(550, $newheight);
				}
				if($gd) {
					$image = $pdf->image_gd($gd, -lossless => 1);
					unlink $png;
				} else {
					$image = $pdf->image_png($png);
					push @tmpfiles, $png;
				}
				$pdfpage = PDFPage->new();
				my $x = 300 - ($image->width() / 2);
				my $y = $pdfpage->y() - $image->height();
				$pdfpage->page()->gfx()->image($image, $x, $y);
				$pdfpage = PDFPage->new();
			}

			# FIXME: This sorting only works when all people are descendents of $me, there are no
			# ancestors involved
			@everyone = sort {
				(stepsabove($a, $me, 0) == stepsabove($b, $me, 0)) ?
					$a->as_sort_key() cmp $b->as_sort_key() :
					stepsabove($a, $me, 0) <=> stepsabove($b, $me, 0);
			} @everyone;

			die "BUG: sort hasn't worked" if($everyone[0] ne $me);
		} elsif($opts{'h'}) {
			# Put a family tree going back a few generations on page 2
			# Go back until it looks like it will be very small text
			my $tmp = File::Temp->new();
			my $filename = $tmp->filename();
			my $png = '/tmp/njh.png';	# FIXME
			my $top = $me;

			my $level = 0;
			while(1) {
				my $parent;
				if($top->father()) {
					$parent = $top->father();
				} elsif($top->mother()) {
					$parent = $top->mother();
				} else {
					last;
				}
				if(count_descendents_at_level($parent, $level + 1) > 20) {
					last;
				}
				$top = $parent;
				$level++;
				# print $top->as_string(), " $level, ", count_descendents_at_level($top, $level), "\n";
			}

			if(($top ne $me) && open(my $fout, '|-', "$dot -Tpng -o$png -Tcmapx -o$filename")) {
			# if(open(my $fout, '|-', '/usr/bin/tee foo')) {
				print $fout 'digraph family {',
					'rotate = 90 subgraph main { rank="0"; ';
				print_graphviz({ person => $top, fout => $fout, format => 'dynamic' });
				print_graphviz_generation({ person => $top, fout => $fout, format => 'dynamic', rank => 0, maxrank => $level + 1 });
				print $fout '}}';
				close $fout;

				my $image;
				my $resize = Image::Resize->new($png);
				my $width = $resize->width();
				my $height = $resize->height();
				my $gd;
				if($height > 715) {
					my $newwidth = $width * (715 / $height);
					my $newheight;
					if($newwidth > 550) {
						$newheight = $height * (550 / $width);
						$gd = $resize->resize(550, $newheight);
					} else {
						$gd = $resize->resize($newwidth, 715);
					}
				} elsif($width > 550) {
					my $newheight = $height * (550 / $width);
					$gd = $resize->resize(550, $newheight);
				}
				if($gd) {
					$image = $pdf->image_gd($gd, -lossless => 1);
					unlink $png;
				} else {
					$image = $pdf->image_png($png);
					push @tmpfiles, $png;
				}
				$pdfpage = PDFPage->new();
				my $x = 300 - ($image->width() / 2);
				my $y = $pdfpage->y() - $image->height();
				$pdfpage->page()->gfx()->image($image, $x, $y);
			}
			@everyone = Sort::Key::keysort { $_->as_sort_key() } @everyone;
		}

		generate(everyone => \@everyone);

		if($opts{'B'}) {
			$pdf->save();
			unlink @tmpfiles;
		}
	} else {
		foreach my $month(0..11) {
			foreach my $day(1..28) {
				generate(day => $day, month => $month, everyone => \@everyone);
			}
			if($month == 1) {
				my $year = DateTime->today()->year();
				next if($year % 4);
				if(($year % 100) == 0) {
					next unless($year % 400);
				}
				generate(day => 29, month => $month, everyone => \@everyone);
				next;
			}
			generate(day => 29, month => $month, everyone => \@everyone);
			generate(day => 30, month => $month, everyone => \@everyone);
			if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
				generate(day => 31, month => $month, everyone => \@everyone);
			}
		}
		generate(day => -1, month => -1, everyone => \@everyone);
	}
} elsif($opts{'b'}) {
	die '-b and -d should not be given together' if($opts{'d'});
	die '-b and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	if($opts{'D'}) {
		print "Today's birthdays:\n";
	}
	generate(day => $day, month => $month, onlybirthdays => 1, onlydeaths => 0, everyone => \@everyone);
	if($opts{'D'}) {
		print "Today's anniversaries of deaths:\n";
		generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1, everyone => \@everyone);
	}
} elsif($opts{'D'}) {
	die '-D and -d should not be given together' if($opts{'d'});
	die '-D and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1, everyone => \@everyone);
} elsif($opts{'p'}) {
	die '-p and -D should not be given together' if($opts{'D'});
	die '-p and -b should not be given together' if($opts{'b'});

	my @people = $ged->get_individual($opts{p});
	if(@people) {
		my($day, $month) = (localtime)[3,4];

		foreach my $person(@people) {
			print_person(person => $person, day => $day, month => $month);
		}
	} else {
		die "$0: Can't find '$opts{p}' in $ARGV[0]";
	}
} elsif(!$opts{'t'}) {
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month, everyone => \@everyone);
} else {
	my %args = ();
	if(defined($ENV{'TZ'})) {
		$args{'time_zone'} = $ENV{'TZ'};
	} else {
		$args{'time_zone'} = DateTime::TimeZone->new(name => 'local');
	}
	my $dt = DateTime->now(%args)->add(days => 1);
	generate(day => $dt->day(), month => $dt->month() - 1, everyone => \@everyone);
}

if($opts{'T'}) {
	# my $g;
	# if(my $oa = $ENV{'OPENADDR_HOME'}) {
		# $g = Geo::Coder::Free::OpenAddresses->new(openaddr => $oa);
	# }
	foreach my $place(sort keys %all_places) {
		print "$place: ";
		my $previous;
		foreach my $person(@{$all_places{$place}}) {
			if($previous && ($person eq $previous)) {
				next;
			}
			print $person->as_string({ include_years => 1, middle_names => 1, nee => 1 }),
				';';
			$previous = $person;
		}
		print "\n";
		# if($g && ($place =~ /USA|Canada/)) {
			# my @locations = $g->geocode($place);
			# if(scalar(@locations) == 0) {
				# # complain(person => $person, warning => "$place not found in Geo::Coder::Free");
				# warn colored(['red'], "$place not found in Geo::Coder::Free");
			# }
		# }
	}
}

sub generate {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $surname_initial;
	if($opts{'B'}) {
		$params{'font'} = $pdf->corefont('Times-Roman');
	}
	my $index = 1;
	my $generation = 0;

	foreach my $person(@{$params{'everyone'}}) {
	# foreach my $person(sort { $a->get_value('last name') cmp $b->get_value('last name') } $ged->individuals()) {
		if($me && ($person eq $me) && !$opts{'a'}) {
			$index++;
			next;
		}

		if(!$printed{$person->{'xref'}}) {
			if($pr) {
				$| = 1;
				$pr->update($index++);
				$pr->write();
				$| = 0;
			}
			if($opts{'B'}) {
				if($opts{'G'}) {
					if(stepsabove($person, $me, 0) != $generation) {
						# FIXME:  only do this if the generation contains dead people if the -l flag is not given
						$pdfpage = PDFPage->new();
						$generation = stepsabove($person, $me, 0);

						my $font = $pdf->corefont('Times-Bold');
						my $text = $pdfpage->text();
						$text->font($font, 18);

						$text->translate(300, $pdfpage->newline());

						my $t;

						if($generation >= 5) {
							$t = ($generation - 2) . ' times great-grandchildren';
						} elsif($generation == 1) {
							$t = 'Children';
						} elsif($generation == 2) {
							$t = 'Grandchildren';
						} elsif($generation == 3) {
							$t = 'Great-grandchilden';
						} elsif($generation == 4) {
							$t = 'Great-great-grandchildren';
						} else {
							# May have found a spouse with the same name, so it shouldn't be included
							next unless($person->father() || $person->mother());
							die $person->as_string(), '/', $me->as_string(), "; -G ($generation): Doesn't yet support ancestors";
						}
						$text->text_center($t);

						$text->font($params{'font'}, 12);
					}
				} else {
					my $surname = $person->surname() || '?';
					my $initial = substr $surname, 0, 1;
					if((!defined($surname_initial)) || ($initial ne $surname_initial)) {
						$pdfpage = PDFPage->new();
						$surname_initial = $initial;
					}
				}
			}

			$params{'person'} = $person;
			print_person(\%params);

			if($opts{'v'}) {
				my $log = $geocoder->log();
				$geocoder->flush();
				foreach my $l(@{$log}) {
					if($l->{'line'}) {
						print 'Line ', $l->{'line'}, ': ';
					}
					if($l->{'error'}) {
						print $l->{'error'}, ', ';
					}
					if($l->{geocoder}) {
						if($l->{error}) {
							print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, '(', $l->{error}, ")\n";
						} else {
							print $l->{location}, ': ', $l->{timetaken}, 's with ', $l->{geocoder}, "\n";
						}
					} else {
						print $l->{location}, ": cached\n";
					}
				}
			}
		}
	}

	if($opts{'B'}) {
		print "\n";
	}
}

sub print_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	# Gather the information on this person
	my $person = $params{'person'};

	$fetcher = Data::Fetch->new();	# Throw away old values from the cache

	my $dob = get_value({ person => $person, value => 'birth date' });

	# ACOM starts approximate dates with "Abt." instead of "ABT".
	if(defined($dob)) {
		$dob =~ s/[\.\-]/ /g;
		$dob =~ s/\s{2,}/ /g;
		$dob =~ s/\(.+$//;	# some people put information in brackets after the date
		if($dob =~ /^About[:\s](.+)/i) {
			$dob = "ABT$1";
		} elsif($dob =~ /^Bet\s[a-z]{3}.+([a-z]{3}\s+.*)/i) {	# Bet Jun-Jul 1860
			$dob = "ABT $1";
		} elsif($dob =~ /^(.+)\s*\?/i) {
			$dob = "ABT$1";
		}
		if(($dob !~ /^[\d\sA-Z\/]+$/i) && ($dob !~ /^Abt\./)) {
			if($dob =~ /(\d{4})\s*(.+)/) {
				my $d = $1;
				my $t = $2;
				# Allow 1914-1918
				if($t !~ /\d{3,4}$/) {
					$dob = "ABT$d";
					if(place({ person => $person, place => $t })) {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the location record" });
					} else {
						complain({ person => $person, warning => "Unexpected text ($t) after the date $d - should be in the note field" });
					}
				}
			} elsif($dob !~ /\d{1,2}$/) {	# Dates can begin with a letter in the US
				complain({ person => $person, warning => "Invalid character in date of birth $dob" });
				$dob = undef;
			}
		}
	}

	my $onlybirthdays = $params{'onlybirthdays'};
	my $onlydeaths = $params{'onlydeaths'};

	die "BUG: onlydeaths and onlybirths given" if($onlydeaths && $onlybirthdays);

	return if($onlybirthdays && !defined($dob));

	my $dod = get_value({ person => $person, value => 'death date' });

	return if($onlydeaths && !defined($dod));

	my $yod;	# Year of death
	if($dod && ($dod =~ /.*?(\d{3,4})/)) {
		$yod = $1;
	}

	my $yob;	# Year of birth
	if($dob && ($dob =~ /.*?(\d{3,4})/)) {
		$yob = $1;
	} elsif($dob) {
		if($dob eq 'UNKNOWN') {
			$dob = undef;
		} elsif($opts{'w'} && !$warned{$person}) {
			complain({ person => $person, warning => "Invalid date of birth $dob" });
			$warned{$person} = 1;
		}
	}

	unless($dob || $dod || $opts{'a'} || $opts{'p'}) {
		return;
	}

	if((!defined($opts{l})) && (!defined($yod)) && defined($yob) && ($yob > 1900)) {
		# Assuming living if we don't have a date of death and
		# they were born after 1900
		return;
	}

	# print 'Checking ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

	my $print = 0;
	my $aob;
	my $aod;
	my $day = $params{'day'};
	my $month = $params{'month'};

	if($day) {
		if($dob && ($dob !~ /^\d{3,4}$/)) {
			my @btime = strptime("$dob 12:00");
			if(defined($btime[3]) && ($btime[3] == $day) && ($btime[4] == $month) && $btime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aob = (localtime)[5] - $btime[5];
					if($aob <= 0) {
						$aob += 1900;
					}
				}
			}
		}
		return if($onlybirthdays && !defined($aob));

		if($dod && ($dod !~ /^\d{3,4}$/)) {
			my @dtime = strptime("$dod 12:00");
			if(defined($dtime[3]) && ($dtime[3] == $day) && ($dtime[4] == $month) && $dtime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aod = (localtime)[5] - $dtime[5];
					if($aod <= 0) {
						$aod += 1900;
					}
				}
			}
		}
		return if($onlydeaths && !defined($aod));

		return unless($print || ($day == -1) || $opts{'p'});
	}

	if($opts{'w'} && !$person->validate_semantics()) {
		complain({ person => $person, warning => 'failed consistency check' });
	}

	my @siblings = $person->siblings();
	my $mother = $person->mother();
	my $father = $person->father();
	my @spouses = $person->spouse();

	# TODO: Properly chart which spouse a child comes from
	if($opts{'w'}) {
		my $family;
		foreach my $f($person->fams()) {
			if($f->number_of_children()) {
				$family = $f;
				last;
			}
		}

		if((!$family) && (scalar(@siblings) == 0) && (!$mother) && (!$father) && (scalar(@spouses) == 0)) {
			# This person isn't connected to anyone
			# TODO: catch "islands" of people connected to each other, but nobody else
			complain({ person => $person, warning => 'not connected to the tree' });
		}

		# FIXME: needs to only complain about more than two biological parents
		my @parents = $person->parents();
		if(scalar(@parents) > 2) {
			complain({ person => $person, warning => 'Has more than two parents' });
		}
	}

	my $year = $params{'year'} || (localtime)[5];
	$year += 1900 if($year < 1900);

	if($opts{'H'}) {
		my $start_of_month = DateTime->new(month => $month + 1, day => 1, year => $year);
		my $dt = DateTime->new(month => $month + 1, day => $day, year => $year);

		my $row = $dt->weekday_of_month();
		my $first_day_of_month = $start_of_month->day_of_week();
		if(($first_day_of_month < 7) && ($dt->day_of_week() < $first_day_of_month)) {
			$row++;
		}
		$row++;
		my $column = $dt->day_of_week();
		my $dtl = $params{'dtl'};

		if($dtl->first_day_of_week() eq 7) {
			$column++;
			if($column == 8) {
				$column = 1;
				$row++ unless($first_day_of_month == 7);
			}
		}
		die "BUG: row cannot be 8 or greater" if($row >= 8);

		my $table = $params{'table'};

		# print STDERR "$row, $column\n";
		my $str = $table->getCell($row, $column);
		if(index($str, $person->as_string()) != -1) {
			$printed{$person->{'xref'}} = 1;
			return;
		}
		$str .= '<br>';
		if($opts{'L'}) {
			$str .= '<a href="/' . make_filename_from_person(person => $person) . '">' .
				$person->as_string() .
				'</a>';
		} else {
			$str .= $person->as_string();
		}
		if($aob) {
			if(my $d = $dfg->parse_datetime(date => get_value({ person => $person, value => 'birth date' }))) {
				$str .= ' b' . $d->strftime('%Y');
			} else {
				red_warning({ person => $person, warning => "Can't parse date of birth '$dob'" });
			}
		}
		if($aod) {
			if(my $d = $dfg->parse_datetime(date => get_value({ person => $person, value => 'death date' }))) {
				$str .= ' d' . $d->strftime('%Y');
			} else {
				red_warning({ person => $person, warning => "Can't parse date of death '$dod'" });
			}
		}

		$table->setCell($row, $column, $str);
		$printed{$person->{'xref'}} = 1;
		return;
	}
	my $person2;
	if($ged2) {
		$person2 = $ged2->get_individual($person->as_string());
		if(!defined($person2)) {
			complain({
				person => $person,
				warning => "not found in $ARGV[1]"
			});
		}
	}

	my $args = {
		include_years => 1,
		middle_names => 1,
		title => 1,
		print_unknown => 1,
	};
	if(!($opts{'A'} || $opts{'G'})) {
		$args->{'nee'} = 1;
	}
	my $text;
	my %places_printed;
	if($opts{'B'}) {
		if($pdfpage->full() || ($pdfpage->linesleft() <= 10)) {
			# Start this person on a new page
			$pdfpage->text()->textend();
			$pdfpage = PDFPage->new();
		} else {
			$pdfpage->newline();
		}
		$text = $pdfpage->text();
		$text->font($params{'font'}, 18);

		$text->translate(25, $pdfpage->newline());
		$text->text($person->as_string($args));

		$text->font($params{'font'}, 12);
	} elsif($opts{'T'}) {
		foreach my $place(get_all_residences($person)) {
			if(my $p = place({ person => $person, record => $place, places_printed => \%places_printed, nopreposition => 1 })) {
				$p =~ s/^\s//;
				push @{$all_places{$p}}, $person;
			}
		}
		for my $event('birth', 'baptism', 'marriage', 'death', 'burial') {
			my $p;
			if(my $r = $person->get_record($event)) {
				$p = place({ person => $person, record => $r, places_printed => \%places_printed, nopreposition => 1 });
			} elsif($p = get_value({ person => $person, value => "$event place" })) {
				$p = place({ person => $person, place => $p, places_printed => \%places_printed, nopreposition => 1 });
			}
			if($p) {
				$p =~ s/^\s//;
				push @{$all_places{$p}}, $person;
			}
		}
		return;
	} else {
		print $person->as_string($args), "\n";
	}

	my $name = $person->name();
	$name =~ s/\///g;
	$nameparser->parse($name);
	my %name_components = $nameparser->components();
	my $firstname = $name_components{'given_name_1'};
	my $lastname = $name_components{'surname_1'};

	if($firstname && ($firstname =~ /\d/)) {
		complain({ person => $person, warning => 'First name contains a digit' });
	}
	if($lastname && ($lastname =~ /\d/)) {
		complain({ person => $person, warning => 'Last name contains a digit' });
	}

	my ($marriage_dt, $death_dt);
	my $birth = $person->get_record('birth');
	my $dateofbirth = get_value({ person => $person, value => 'birth date' });
	if((!$dateofbirth) && $birth) {
		$dateofbirth = $birth->date();
	}
	my $placeofbirth = get_value({ person => $person, value => 'birth place' });
	if((!$placeofbirth) && $birth) {
		$placeofbirth = $birth->place();
	}

	if($placeofbirth && ($placeofbirth =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in birth location '$placeofbirth'" });
		$placeofbirth = "$1, USA";
		$birth_country = 'United States';
	} elsif($placeofbirth && ($placeofbirth =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			$birth_country = 'United States';
		} elsif($c eq 'Texas') {
			$birth_country = 'United States';
		} elsif($c eq 'United States of America') {
			$birth_country = 'United States';
		} elsif($c eq 'Scotland') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Isle of Man') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Northern Ireland') {
			$birth_country = 'United Kingdom';
		} elsif($c eq 'Preußen') {	# Prussia
			$birth_country = 'Germany';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			$birth_country = $b->code_alpha2();
		} else {
			complain({ person => $person, warning => "Unknown birth country: '$c' in '$placeofbirth'" });
		}
	}

	my $death = $person->get_record('death');
	my $dateofdeath = get_value({ person => $person, value => 'death date' });
	if((!$dateofdeath) && $death) {
		$dateofdeath = $death->date();
	}
	my $placeofdeath = get_value({ person => $person, value => 'death place' });
	if((!$placeofdeath) && $death) {
		$placeofdeath = $death->place();
	}

	if($placeofdeath && ($placeofdeath =~ /(.+[a-z]) USA$/)) {
		complain({ person => $person, warning => "Comma missing before USA in death location '$placeofdeath'" });
		$placeofdeath = "$1, USA";
	} elsif($placeofdeath && ($placeofdeath =~ /.+,\s?(.+)$/)) {
		my $c = $1;
		if($c eq 'England') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'USA') {
			# $death_country = 'United States';
		# } elsif($c eq 'Texas') {
			# $death_country = 'United States';
		# } elsif($c eq 'United States of America') {
			# $death_country = 'United States';
		} elsif($c eq 'Scotland') {
			# $death_country = 'United Kingdom';
		} elsif($c eq 'Wales') {
			# $death_country = 'United Kingdom';
		# } elsif($c eq 'Isle of Man') {
			# $death_country = 'United Kingdom';
		# } elsif($c eq 'Northern Ireland') {
			# $death_country = 'United Kingdom';
		# } elsif($c eq 'Preußen') {	# Prussia
			# $death_country = 'Germany';
		} elsif(my $b = Locale::Object::Country->new(name => $c)) {
			# $death_country = $b->code_alpha2();
		} else {
			complain({ person => $person, warning => "Unknown death country: '$c' in '$placeofdeath'" });
		}
	}

	my %citations;
	my $citationcount = 0;
	my @birthcitations;
	my @deathcitations;
	if($opts{'c'}) {
		if($birth) {
			if($opts{'w'}) {
				foreach my $s($birth->source()) {
					if(!defined(get_source({ gedcom => $ged, person => $person, source => $s }))) {
						complain({ person => $person, warning => 'Citation is missing a source' });
					}
				}
			}
			my @s = sort { (get_source({ gedcom => $ged, person => $person, source => $a }) && get_source({ gedcom => $ged, person => $person, source => $b })) ? get_source({ gedcom => $ged, person => $person, source => $a })->title() cmp get_source({ gedcom => $ged, person => $person, source => $b })->title() : 0 } $birth->source();
			if(scalar(@s)) {
				my $previous;
				foreach my $src(@s) {
					$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
					if(defined($src) && (my $title = $src->title())) {
						if($previous && ($title eq $previous)) {
							next;
						}
						$previous = $title;
						push @birthcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
			} elsif($opts{'w'}) {
				if($dateofbirth) {
					complain({ person => $person, warning => "Birth date ($dateofbirth) has no citations" });
				} else {
					complain({ person => $person, warning => "Birth place ($placeofbirth) has no citations" });
				}
			}
		}
		if($death) {
			my @s = $death->source();
			if(scalar(@s)) {
				foreach my $src(@s) {
					$src = $ged->get_source($src) unless ref($src);
					my $seen;
					foreach my $bc(@birthcitations) {
						if($src eq $citations{$bc}) {
							push @deathcitations, $bc;
							$seen++;
							last;
						}
					}
					if(!$seen) {
						push @deathcitations, ++$citationcount;
						$citations{$citationcount} = $src;
					}
				}
			} elsif($opts{'l'} || !is_alive(person => $person)) {
				if($dateofdeath) {
					# my $dateismissing = 0;
					# my @objects = $person->obje();
					# foreach my $o(@objects) {
						# my $obje;
						# if(ref($o) eq 'Gedcom::Record') {
							# $obje = $o;	# e.g. Ancestry
						# } else {
							# $obje = $ged->resolve_xref($o);	# e.g. FMP
						# }
						# foreach my $item($obje->items()) {
							# next if($item->tag() ne '_DATE');
							# if($item->value() eq $dateofdeath) {
								# $dateismissing = 0;
								# last;
							# }
						# }
					# }
					# if($dateismissing) {
						complain({ person => $person, warning => "Death date ($dateofdeath) has no citations" });
					# }
				} elsif($placeofdeath) {
					complain({ person => $person, warning => "Death place ($placeofdeath) has no citations" });
				} else {
					complain({ person => $person, warning => 'Death record exists with no date or place' });
				}
			}
		}
	}

	my @events = $person->event();

	if(scalar(@events) > 1) {
		my $all_have_dates = 1;
		foreach my $event(@events) {
			if(!ref($event)) {
				$all_have_dates = 0;
				last;
			}
			if(ref($event) ne 'Gedcom::Record') {
				$all_have_dates = 0;
				last;
			}
			if(my $date = $event->date()){
				if(!$dfg->parse_datetime(date => $date)) {
					$all_have_dates = 0;
					last;
				}
			} else {
				$all_have_dates = 0;
				last;
			}
		}
		if($all_have_dates) {
			# print join(' ', map { $_->date() } @events), "\n";
			@events = Sort::Key::DateTime::dtkeysort { $dfg->parse_datetime(date => $_->date()) } @events;
			# print join(' ', map { $_->date() } @events), "\n";
		}
	}

	my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage');
	if((!defined($marriage)) && scalar(@spouses)) {
		$marriage = $spouses[0]->get_record('marriage');
		if((!defined($marriage)) && scalar(@spouses)) {
			if(scalar(@events) == 1) {
				my $event = $person->event();
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN');
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					}
				}
				if((ref($event) eq 'Gedcom::Record') &&
				  ($event->type() eq 'Custom Marriage')) {
					# FindMyPast
					$marriage = $event;
				}
			} else {
				foreach my $event(@events) {
					if((ref($event) eq 'Gedcom::Record') &&
					  ($event->type() eq 'Custom Marriage')) {
						# FindMyPast
						$marriage = $event;
						last;
					}
				}
			}
		}
	}

	my $birth_dt = date_to_datetime(date => $dateofbirth);

	if($birth_dt && (my $spouse = $spouses[0])) {
		my $sdob = get_value({ person => $spouse, value => 'birth date' });
		if((!$sdob) && (my $sb = $spouse->get_record('birth'))) {
			$sdob = $sb->date();
		}
		if($sdob && (my $sbirth_dt = date_to_datetime(date => $sdob))) {
			if($sbirth_dt > ($birth_dt + $fortyyears)) {
				complain({
					person => $person,
					warning => 'Spouse born more than 40 years after date of birth'
				});
			} elsif($birth_dt > ($sbirth_dt + $fortyyears)) {
				complain({
					person => $person,
					warning => 'Born more than 40 years after date of birth of spouse'
				});
			}
		}
	}

	my $dateofmarriage = get_value({ person => $person, value => 'marriage date' });
	if((!$dateofmarriage) && $marriage) {
		$dateofmarriage = $marriage->date();
	}
	$marriage_dt = date_to_datetime(date => $dateofmarriage);

	if($birth_dt && $marriage_dt && $opts{'w'} && ($marriage_dt < ($birth_dt + $sixteenyears))) {
		if($opts{'f'}) {
			die $person->as_string(),
				': married when less than 16 years old';
		}
		red_warning({
			person => $person,
			warning => 'married when less than 16 years old'
		});
	}

	$death_dt = date_to_datetime(date => $dateofdeath);

	if($opts{'d'} || $opts{'B'}) {
		# $fetcher->prime(object => $person, message => 'sex')->prime(object => $person, message => 'pronoun');

		my $baptism = $person->get_record('baptism');
		my $dateofbaptism = get_value({ person => $person, value => 'baptism date' });
		if((!$dateofbaptism) && $baptism) {
			$dateofbaptism = $baptism->date();
		}
		my $placeofbaptism = get_value({ person => $person, value => 'baptism place' });
		if((!$placeofbaptism) && $baptism) {
			$placeofbaptism = $baptism->place();
		}

		my $placeofmarriage = get_value({ person => $person, value => 'marriage place' });
		if((!$placeofmarriage) && $marriage) {
			$placeofmarriage = $marriage->place();
		}

		my $burial = $person->get_record('burial');
		my $dateofburial = get_value({ person => $person, value => 'burial date' });
		if((!$dateofburial) && $burial) {
			$dateofburial = $burial->date();
		}
		my $placeofburial = get_value({ person => $person, value => 'burial place' });
		if((!$placeofburial) && $burial) {
			$placeofburial = $burial->place();
		}

		my $marriagecitation;
		my @burialcitations;
		if($opts{'c'}) {
			if($marriage) {
				if(my $src = $marriage->source()) {
					$src = $ged->get_source($src) unless ref($src);
					# FIXME:  Only looks for matches in the first citations
					if(!defined($src)) {
						if($opts{'w'}) {
							my $src = $marriage->source();
							complain({ person => $person, warning => "marriage citation can't find source $src" });
						}
					} elsif($birthcitations[0] && ($citations{$birthcitations[0]} eq $src)) {
						$marriagecitation = $birthcitations[0];
					} elsif($deathcitations[0] && ($citations{$deathcitations[0]} eq $src)) {
						$marriagecitation = $deathcitations[0];
					} else {
						$marriagecitation = ++$citationcount;
						$citations{$marriagecitation} = $src;
					}
				} elsif($opts{'w'}) {
					if($dateofmarriage) {
						red_warning({ person => $person, warning => "Marriage date ($dateofmarriage) has no citations" });
					} else {
						red_warning({ person => $person, warning => "Marriage place ($placeofmarriage) has no citations" });
					}
				}
			}
			if($burial) {
				my @s = $burial->source();
				if(scalar(@s)) {
					foreach my $src(@s) {
						$src = $ged->get_source($src) unless ref($src);
						if(!defined($src)) {
							if($opts{'w'}) {
								my $src = $burial->source();
								if($opts{'f'}) {
									die $person->as_string(), ": burial citation can't find source $src";
								}
								red_warning({ person => $person, warning => "burial citation can't find source $src" });
							}
							next;
						}
						my $seen;
						foreach my $dc(@deathcitations) {
							if($src eq $citations{$dc}) {
								push @burialcitations, $dc;
								$seen++;
								last;
							}
						}
						if(!$seen) {
							if($marriagecitation && ($citations{$marriagecitation} eq $src)) {
								push @burialcitations, $marriagecitation;
							} else {
								push @burialcitations, ++$citationcount;
								$citations{$citationcount} = $src;
							}
						}
					}
				} elsif($opts{'w'}) {
					if($dateofburial) {
						complain({ person => $person, warning => "Burial date ($dateofburial) has no citations" });
					} else {
						complain({ person => $person, warning => "Burial place ($placeofburial) has no citations" });
					}
				}
			}
		}

		my $pronoun = $fetcher->get(object => $person, message => 'pronoun');
		my $sex = $fetcher->get(object => $person, message => 'sex');

		if($opts{'w'} && $firstname) {
			# FIXME: This throws up a number of false positives
			my $guess;
			if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
				$guess = Text::Names::guessGender($firstname);
			} else {
				$guess = Text::Names::GB::guessGender($firstname);
			}
			if($sex && $guess && ($sex ne $guess)) {
				my $error = 1;
				if(my $middle_name = $name_components{'middle_name'}) {
					if($placeofbirth && ($placeofbirth =~ /, USA$/)) {
						$guess = Text::Names::guessGender($middle_name);
					} else {
						$guess = Text::Names::GB::guessGender($middle_name);
					}
					if($guess && ($sex eq $guess)) {
						$error = 0;
					}
				}
				if($error) {
					complain({ person => $person, warning => 'Check the gender of the record' });
				}
			}
		}
		my @occupations = $person->get_value('occupation');

		my @children;
		foreach my $f($person->fams()) {
			@children = (@children, $f->children());
		}
		my $numberofchildren = scalar(@children);

		if($opts{'w'} && $numberofchildren) {
			foreach my $child(@children) {
				if($child eq $person) {
					complain({ person => $person, warning => 'person is own parent' });
					# Avoid loops in G::I::Relationship
					return;
				}
			}
		}

		my $relationship;
		my $spouserelationship;
		my $spouse;

		if($dateofbirth && $opts{'w'} && scalar(@siblings)) {
			foreach my $sibling(@siblings) {
				my $siblingbirth = get_value({ person => $sibling, value => 'birth date' });
				if($siblingbirth && ($siblingbirth eq $dateofbirth) &&
				  (($sibling->name() eq $person->name()) || Text::Names::samePerson($sibling->name(), $person->name()))) {
					complain({ person => $sibling, warning => 'possible duplicate person' });
				}
			}
		}

		if($me && ($person ne $me) && !$opts{'G'}) {
			$relationship = $me->relationship($person);
			if((!$relationship) && scalar(@spouses)) {
				if($person->spouse() eq $me) {
					$relationship = ($sex eq 'F') ? 'wife' : 'husband';
				} else {
					foreach my $s(@spouses) {
						$spouserelationship = $me->relationship($s);
						if($spouserelationship) {
							$spouse = $s;
							last;
						}
					}
				}
			}
			if((!$relationship) && (!$spouserelationship)) {
				complain({
					person => $person,
					warning => "Can't find relationship with the home person"
				});
			}
		}

		while($occupations[0] && ($occupations[0] =~ /^scho(ol|lar)/i)) {
			shift @occupations;
		}
		while($occupations[0] && ($occupations[0] =~ /wife$/i)) {
			shift @occupations;
		}
		while(scalar(@occupations) > 1) {
			if(($occupations[0] =~ /labou?rer/i) && ($occupations[1] =~ /labou?rer/i)) {
				shift @occupations;
			} elsif($occupations[0] eq $occupations[1]) {
				shift @occupations;
			} else {
				last;
			}
		}

		my $same_occupation_as_father;
		my $printed_comma = 0;

		my $bio = "\t";

		if($occupations[0]) {
			if($father && $father->occupation() && ($occupations[0] eq $father->occupation())) {
				$same_occupation_as_father = $occupations[0];
				@occupations = ();
			} else {
				$bio .= 'A';
				if($occupations[0] =~ /^works on (.+)/i) {
					$occupations[0] = "$1 worker";
				}
				if($occupations[0] =~ /^[aeiou]/i) {
					$bio .= 'n';
				}
				$bio .= ' ';
				if($occupations[1]) {
					# my $alloccupations = join(', ', @occupations);
					# substr($alloccupations, rindex($alloccupations, ', '), 2, ' and ');
					# print lc($alloccupations);
					$bio .= lc(Lingua::EN::Inflect::WORDLIST(@occupations, {final_sep => ''}));
				} else {
					$bio .= lc($occupations[0]);
				}
				if(!($father || $mother || $spouserelationship)) {
					$bio .= ', ';
					$printed_comma = 1;
				}
			}
		} elsif(scalar(@occupations)) {
			complain({
				person => $person,
				warning => 'occupation is empty'
			});
			shift @occupations;
		}

		my @twins;
		if($birth_dt) {
			foreach my $s(@siblings) {
				if(my $dob = get_value({ person => $s, value => 'birth date' })) {
					if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
						my $d;
						eval {
							$d = $date_parser->parse(date => $dob);
						};
						if($d) {
							$d = @{$d}[0];
						}
						if($d) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if(($d == $birth_dt) || ($d == ($birth_dt - $oneday)) || ($d == ($birth_dt + $oneday))) {
								push @twins, $s;
							}
						}
					}
				}
			}
			if(scalar(@twins) == 1) {	# TODO triplets and higher order
				if(scalar(@occupations)) {
					$bio .= ', twin of ' . $twins[0]->given_names();
				} else {
					$bio .= 'The twin ' . (($person->sex() eq 'M') ? 'brother' : 'sister') .
						' of ' . $twins[0]->given_names();
				}
			}
		}

		my $print_sibling_count = 0;

		if($father || $mother) {
			if(scalar(@occupations) || scalar(@twins)) {
				$bio .= ' and the ';
			} else {
				$bio .= "The ";
			}

			if($birth_dt) {
				if(scalar(@siblings)) {
					# If possible, sort siblings by date of birth
					my $all_siblings_have_dob = 1;
					foreach my $sibling(@siblings) {
						if(my $dob = get_value({ person => $sibling, value => 'birth date' })) {
							if(($dob !~ /^\d/) || ($dob =~ /[a-z]$/i) ||
							   ($dob =~ /[\/\-]/) || !date_parser_cached(date => $dob)) {
								$all_siblings_have_dob = 0;
								last;
							}
							my $d;
							eval {
								$d = $date_parser->parse(date => $dob);
							};
							if($d) {
								$d = @{$d}[0];
							}
							if($@ || !defined($d)) {
								complain({
									person => $sibling,
									warning => "has an invalid date of birth: $dob"
								});
								$all_siblings_have_dob = 0;
								last;
							}
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					}
					if($all_siblings_have_dob) {
						@siblings = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => get_value({ person => $_, value => 'birth date' }))}[0]->{'canonical'}) } @siblings;
					}
					my $age_index = 1;	# count of siblings born before $person + 1 (i.e. where $person is in the date order)
					$print_sibling_count = 1;
					foreach my $sibling(@siblings) {
						if(my $dob = get_value({ person => $sibling, value => 'birth date' })) {
							if(my $d = date_parser_cached(date => $dob)) {
								$d = $dfn->parse_datetime($d->{'canonical'});
								if($opts{'w'} &&
								  ($dob =~ /^\d/) && ($dob !~ /[a-z]$/i) &&
								  ($d < $birth_dt) &&
								  ($d < ($birth_dt - $oneday)) &&
								  ($d > ($birth_dt - $tenmonths))) {
									complain({
										person => $sibling,
										warning => 'Born less than 10 months before sibling ' . $person->as_string()
									});
								}
								$age_index++ if($d && ($d < $birth_dt));
							} else {
								$all_siblings_have_dob = 0;
								last;
							}
						} else {
							$all_siblings_have_dob = 0;
							last;
						}
					}
					if($all_siblings_have_dob) {
						if(scalar(@siblings) && ($age_index == (scalar(@siblings) + 1))) {
							$bio .= ((scalar(@siblings) > 1) ? 'youngest' : 'younger');
						} elsif(scalar(@siblings) && ($age_index == 1)) {
							$bio .= ((scalar(@siblings) > 1) ? 'eldest' : 'older');
						} else {
							$bio .= ordinate($age_index);
						}
						$bio .= ' of ' . (scalar(@siblings) + 1) . ' children';
					} else {
						$bio .= 'child';
					}
				} else {
					# print ' only child of';
					$bio .= 'child';
				}
			} else {
				$bio .= 'child';
			}

			$bio .= ' of';

			if($father) {
				$bio .= ' ' . $father->as_string();
				if(!$same_occupation_as_father) {
					my @occupations = $father->get_value('occupation');
					while($occupations[0] && ($occupations[0] =~ /^scho(ol|lar)/i)) {
						shift @occupations;
					}
					# TODO: print all occupations
					if($occupations[0]) {
						$bio .= ' (a';
						if($occupations[0] =~ /^[aeiou]/i) {
							$bio .= 'n';
						}
						$bio .= ' ';
						if(defined($ENV{'LANG'})) {
							if($ENV{'LANG'} =~ /^en_US/) {
								$bio .= Lingua::EN::ABC::b2a(lc($occupations[0]));
							} elsif($ENV{'LANG'} =~ /^en_GB/) {
								$bio .= Lingua::EN::ABC::a2b(lc($occupations[0]));
							}
						} else {
							$bio .= lc($occupations[0]);
						}
						$bio .= ')';
					}
				}
				if($mother) {
					$bio .= ' and';
				} else {
					$bio .= ', ';
					$printed_comma = 1;
				}
			}
			if($mother) {
				if(my $m = $mother->as_string(give_maidenname => 0)) {
					$bio .=  " $m";
				}
				my @occupations = $mother->get_value('occupation');
				while($occupations[0] && ($occupations[0] =~ /^scho(ol|lar)/i)) {
					shift @occupations;
				}
				while($occupations[0] && ($occupations[0] =~ /wife$/i)) {
					shift @occupations;
				}
				while($occupations[0] && ($occupations[0] =~ /Unpaid domestic duties/i)) {
					shift @occupations;
				}
				# TODO: print all occupations
				if($occupations[0]) {
					$bio .= ' (a';
					if($occupations[0] =~ /^[aeiou]/i) {
						$bio .= 'n';
					}
					$bio .= ' ' . lc($occupations[0]) . ')';
				}
				if($opts{'w'}) {
					my $mdod = get_value({ person => $mother, value => 'death date' });
					if($mdod && $birth_dt) {
						if(my $dt = date_to_datetime(date => $mdod)) {
							if($birth_dt > $dt) {
								complain({ person => $person, warning => 'Born after mother died' });
							}
						}
					}
				}
			}
			if(($aob || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || scalar(@spouses) || $relationship) && ($occupations[0])) {
				$bio .= ', ';
				$printed_comma = 1;
			}
		}

		my $haveprintedspousename;
		if($relationship) {
			if($father || $mother || $occupations[0]) {
				if($aob || $aod || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || scalar(@spouses)) {
					$bio .= ', ' unless($printed_comma);
				} elsif(is_alive(person => $person)) {
					$bio .= $person->as_string() . ' is ';
				} else {
					if($opts{'p'} || $opts{'a'}) {
						$bio .= ', ' unless($printed_comma);
					}
					$bio .= $person->as_string() . ' was ';
				}
				$bio .= 'your';
			} else {
				$bio .= 'Your';
			}
			$bio .= " $relationship";
		} elsif($spouserelationship) {
			if($father || $mother || $occupations[0]) {
				$bio .= ', ' unless($printed_comma);
				if($firstname) {
					$bio .= $firstname;
				} else {
					$bio .= $pronoun;
				}
				$bio .= ', the ';
			} else {
				$bio .= $person->as_string();
				if($aob || $aod || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) {
					$bio .= ', the ';
				} elsif(is_alive(person => $person)) {
					$bio .= ' is the ';
				} else {
					$bio .= ' was the ';
				}
			}
			if($sex eq 'F') {
				$bio .= 'wife';
			} else {
				$bio .= 'husband';
			}
			$bio .= " of your $spouserelationship";
			if(my $s = $spouse->as_string({ middle_names => 1, title => 1 })) {
				$bio .= " $s";
			} else {
				complain({ person => $spouse, warning => "seems to have no name" });
			}
			if($aob || $aod || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) {
				$bio .= ',';
			}
			$haveprintedspousename = 1;
		} elsif(($mother || $father) && ($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || $dateofmarriage) && !$printed_comma) {
			$bio .= ', ';
		}

		if(($dateofbaptism || $placeofbaptism) && !($mother || $father) && $relationship) {
			complain({ person => $person, warning => 'Baptism information not used to determine a parent' });
		}

		if(!$spouserelationship) {
			if($aob || $dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism || scalar(@spouses)) {
				if($relationship) {
					$bio .= ' ';
				}
				if($firstname) {
					$bio .= $firstname;
				} else {
					$bio .= $pronoun;
				}
			}
		}

		if(my $aka = $person->as_string({ use_aka => 1 })) {
			$bio .= " (also known as $aka)";
		}

		my $end_of_sentence = 0;
		if($aob && $aod) {
			if($aob == $aod) {
				$bio .= " was born and died $aod years ago ";
			} else {
				$bio .= " was born $aob years and died $aod years ago ";
			}
			$bio .= ($opts{'t'} ? 'tomorrow' : 'today');
			$bio .= "[$_]" foreach(@birthcitations);
			$bio .= "[$_]" foreach(@deathcitations);
			$bio .= '. ';
			$end_of_sentence = 1;
		} elsif($aob) {
			$bio .= " was born $aob " . (($aob == 1) ? 'year' : 'years') . ' ago ' .
				($opts{'t'} ? 'tomorrow' : 'today');
			if($placeofbirth) {
				my $p = place({ person => $person, record => $birth, places_printed => \%places_printed });
				$bio .= $p;
				$places_printed{$p} = 1;
			}
			$bio .= "[$_]" foreach(@birthcitations);
			$bio .= '. ';
			$end_of_sentence = 1;
		} elsif($aod) {
			$bio .= " died $aod " . (($aod == 1) ? 'year' : 'years') . ' ago ' .
				($opts{'t'} ? 'tomorrow' : 'today');
			if($placeofdeath) {
				$bio .= place({ person => $person, record => $death, places_printed => \%places_printed });
			}
			$bio .= "[$_]" foreach(sort @deathcitations);
			if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 0 }))) {
				$notes =~ s/\.$//;
				$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
				$bio .= " ($notes).";
				if(length($notes) > 160) {
					$bio .= "\n\t";
				} else {
					$bio .= ' ';
				}
			} else {
				$bio .= '. ';
			}
			$end_of_sentence = 1;
		}

		my @residences = get_all_residences($person);

		if((!$aob) && ($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism)) {
			$bio .= " $pronoun" if($aob || $aod);
			if($dateofbirth || $placeofbirth) {
				$bio .= ',' if($print_sibling_count && (!$opts{'a'}) && (!$aob) && (!$aod) && !$opts{'p'});

				$bio .= ' was born';
				if($placeofbirth) {
					if($aod && $placeofdeath && ($placeofbirth eq $placeofdeath) && !$death->address()) {
						$bio .= ' there';
					} else {
						$bio .= place({ person => $person, place => $placeofbirth, places_printed => \%places_printed });
					}
				}
				if($dateofbirth) {
					my $y = year({
						person => $person,
						date => $dateofbirth,
						must_predate => $death_dt
					});
					$bio .= " $y" if($y);
				}
				$bio .= "[$_]" foreach(@birthcitations);
				if($opts{'w'}) {
					if($mother && $yob && (my $mumdateofbirth = get_value({ person => $mother, value => 'birth date' }))) {
						if($mumdateofbirth =~ /.*?(\d{3,4})/) {
							$mumdateofbirth = $1;
							if(($yob - $mumdateofbirth) <= 13) {
								complain({
									person => $person,
									warning => "something is wrong with the date of birth which is less than 13 years after the mother was born ($mumdateofbirth)"
								});
							} elsif(($yob - $mumdateofbirth) >= 52) {
								complain({
									person => $person,
									warning => "something is wrong with the date of birth which is more than 52 years after the mother was born ($mumdateofbirth)"
								});
							}
						}
					}
					if($father && $yob && (my $daddateofbirth = get_value({ person => $father, value => 'birth date' }))) {
						if($daddateofbirth =~ /.*?(\d{3,4})/) {
							$daddateofbirth = $1;
							if(($yob - $daddateofbirth) <= 13) {
								complain({
									person => $person,
									warning => "something is wrong with the date of birth which is less than 13 years after the father was born ($daddateofbirth)"
								});
							}
						}
					}
					if($death_dt || ($dateofdeath && ($dateofdeath =~ /^\d{3,4}$/))) {
						# TODO: Add more checking
						my $yod;
						if($death_dt) {
							$yod = $death_dt->year();
						} elsif($dateofdeath =~ /^(\d{3,4})$/) {
							$yod = $1;
						} else {
							die "BUG: Impossible case";
						}
						foreach my $bc(@birthcitations) {
							my $citation = $citations{$bc};
							my $title = $citation->title();
							if($title =~ /^(\d{3,4})\s/) {
								if($1 > $yod) {
									complain({
										person => $person,
										warning => "Year of citation of $title is after the death year of $yod"
									});
								}
							}
						}
					}
				}
				if($dateofbaptism || $placeofbaptism) {
					if(scalar(@spouses) && ($aod || $aob) && ($numberofchildren > 0) && !($opts{'a'} || $opts{'p'})) {
						$bio .= ', was';
					} else {
						$bio .= ' and';
					}
				} elsif($birth_dt) {
					my @twins;
					foreach my $s(@siblings) {
						if(my $dob = get_value({ person => $s, value => 'birth date' })) {
							if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
								my $d;
								eval {
									$d = $date_parser->parse(date => $dob);
								};
								if($d) {
									$d = @{$d}[0];
								}
								if($d) {
									$d = $dfn->parse_datetime($d->{'canonical'});
									if(($d == $birth_dt) || ($d == ($birth_dt - $oneday)) || ($d == ($birth_dt + $oneday))) {
										push @twins, { sibling => $s, dob => $d };
									}
								}
							}
						}
					}
					if(scalar(@twins) == 1) {	# TODO triplets and higher order
						my $t = $twins[0];
						my $sibling = $t->{'sibling'};
						my $dob = $t->{'dob'};
						if($dob == $birth_dt) {
							$bio .= ', the same day as ';
						} elsif($dob == ($birth_dt + $oneday)) {
							$bio .= ', a day before ';
						} else {
							$bio .= ', a day after ';
						}
						$bio .= ($sex eq 'M' ? 'his' : 'her') . ' twin ' .
							(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
							$sibling->given_names();
					}
				}
				$end_of_sentence = 0;
			}
			if($dateofbaptism || $placeofbaptism) {
				$bio .= ' ';
				unless($dateofbirth || $placeofbirth) {
					$bio .= 'was ';
				}
				if($ENV{'LANG'} =~ /^en_US/) {
					$bio .= 'baptized';
				} else {
					$bio .= 'baptised';
				}
				if($placeofbaptism) {
					if(($aod || $opts{'a'} || $opts{'p'}) && $placeofbirth && ($placeofbaptism eq $placeofbirth)) {
						$bio .= ' there';
						if(my $address = $baptism->address()) {
							if($address =~ /(.+),\s*$placeofbirth$/) {
								$address = $1;
							}
							$bio .= " at $address";
						}
					} else {
						my $p = place({ person => $person, place => $placeofbaptism });
						$bio .= $p;
						$places_printed{$p} = 1;
					}
				}
				if($dateofbaptism) {
					if($opts{'w'} && $yob && ($dateofbaptism =~ /(\d{3,4})$/)) {
						# must_predate doesn't work when only years are known
						if($1 < $yob) {
							if($opts{'f'}) {
								die $person->as_string(), ": Year of baptism $1 is before the year of birth $yob";
							}
							red_warning({
								person => $person,
								warning => "Year of baptism $1 is before the year of birth $yob"
							});
						}
					}
					$bio .= ' ' . year({
						person => $person,
						date => $dateofbaptism,
						must_postdate => $birth_dt,
						must_predate => $death_dt
					});
					if(!$death_dt) {
						must_predate({
							person => $person,
							date => $dateofbaptism,
							predate => $dateofdeath
						});
					}
					$bio .= print_sibling_baptism({
						person => $person,
						siblings => \@siblings,
						date => $dateofbaptism,
						birthdate => $dateofbirth,
					});
					if($mother && $opts{'w'}) {
						if($dateofbaptism =~ /.*?(\d{3,4})/) {
							my $yobaptism = $1;
							my $motherdob = get_value({ person => $mother, value => 'birth date' });
							if($motherdob) {
								my $d = $date_parser->parse(date => $motherdob);
								if($d && (ref($d) eq 'ARRAY')) {
									$d = @{$d}[0];
									if(defined($d) && !$d->{'flag'}) {
										$d = $dfn->parse_datetime($d->{'canonical'})->strftime('%Y');
										if($d > ($yobaptism - 13)) {
											complain({
												person => $person,
												warning => "something is wrong with the date of baptism which is less than 13 years after the mother was born ($d)"
											});
										}
									}
								}
							}
						} else {
							complain({
								person => $person,
								warning => "invalid date of baptism $dateofbaptism"
							});
							$warned{$person} = 1;
						}
					}
				}
				$end_of_sentence = 0;
			}
			if(scalar(@spouses) && ($aod || $aob) && ($numberofchildren > 0)) {
				# $bio .= ' and';
			} else {
				$bio .= '. ';
				$end_of_sentence = 1;
			}
		} elsif($aob && ($dateofbaptism || $placeofbaptism)) {
			$bio .= " $pronoun was ";

			if($ENV{'LANG'} =~ /^en_US/) {
				$bio .= 'baptized';
			} else {
				$bio .= 'baptised';
			}
			if($placeofbaptism) {
				if($placeofbirth && ($placeofbaptism eq $placeofbirth)) {
					if($aod) {
						$bio .= ' in ' .
							lcfirst($person->possessive()) .
							' home town';
					} else {
						$bio .= ' there';
						if(my $address = $baptism->address()) {
							$bio .= " at $address";
						}
					}
				} else {
					my $opts = {
						person => $person,
						place => $placeofbaptism,
						places_printed => \%places_printed
					};
					my $address = $baptism->address();
					if($address) {
						$opts{'address'} = $address;
					}
					my $p = place($opts);
					$bio .= $p;
					$places_printed{$p} = 1;
				}
			}
			if($dateofbaptism) {
				$bio .= ' ' . year({
					person => $person,
					date => $dateofbaptism,
					must_postdate => $birth_dt,
					must_predate => $death_dt
				});
				$bio .= print_sibling_baptism({
					person => $person,
					siblings => \@siblings,
					date => $dateofbaptism,
					birthdate => $dateofbirth,
				});
			}
			if(scalar(@spouses)) {
				if(!scalar(@residences)) {
					$bio .= ',';
				}
				$end_of_sentence = 0;
			} else {
				$bio .= '. ';
				$end_of_sentence = 1;
			}
		}

		my $all_children_are_alive = 1;

		if($yob && ($year >= $yob + 150)) {
			$all_children_are_alive = 0;
		} else {
			foreach my $child(@children) {
				if(!is_alive(person => $child)) {
					$all_children_are_alive = 0;
					last;
				}
			}
		}
		my @childrenunknownparent;
		# TODO: children != 0 && spouses == 0
		if(scalar(@spouses) &&
		   ((!$spouserelationship) || $placeofmarriage || $dateofmarriage)) {
			$bio .= " $pronoun" if($end_of_sentence);

			if(scalar(@spouses) == 1) {
				if($placeofmarriage || $dateofmarriage) {
					# if(($numberofchildren == 0) && (scalar(@residences) == 0) && (!($aob || $opts{'p'} || $opts{'G'} || $opts{'B'})) && !$all_children_are_alive) {
					if(!$end_of_sentence) {
						$bio .= ' and';
					}
					$bio .= ' married ';
				} elsif(is_alive(person => $person) && is_alive(person => $spouses[0])) {
					$bio .= ' is married to ';
				} else {
					if(($aod || ((!defined($placeofdeath)) && !defined($dateofdeath))) && (!defined($placeofburial)) && (!defined($dateofburial)) && (!($aob || $opts{'p'} || $opts{'G'} || $opts{'B'}))) {
						$bio .= ' and';
					}
					$bio .= ' was married to ';
				}
				if($haveprintedspousename) {
					$nameparser->parse($spouses[0]->name());

					my %name_components = $nameparser->components();
					if(my $n = $name_components{'given_name_1'}) {
						$bio .= $n;
					} else {
						complain({ person => $spouses[0], warning => 'seems to have no name' });
					}
				} else {
					$bio .= $spouses[0]->as_string();
					$haveprintedspousename = 1;
				}
				my $parentheses = 0;
				if($numberofchildren) {
					# if((!$placeofmarriage) && !$dateofmarriage) {
						# $bio .= ', ';
					# }
					if(my $soccupation = $spouses[0]->occupation()) {
						if(($soccupation !~ /^scho(ol|lar)/i) && ($soccupation !~ /wife$/i)) {
							$bio .= ' (';
							$parentheses = 1;
							if(ref($soccupation) eq 'Gedcom::Record') {
								my @items = $soccupation->items();
								$soccupation = $items[0]->value();
							}
							if(lc($soccupation) eq 'self-employed') {
								$bio .= 'self-employed ';
							} else {
								$bio .= 'a';
								if($soccupation =~ /^[aeiou]/i) {
									$bio .= 'n';
								}
								$bio .= ' ' . lc($soccupation) . ' ';
							}
						}
					}
					my @childrenofthisspouse;
					my $numberofchildrenwiththisspouse = $numberofchildren;
					my $spouse = $spouses[0];
					foreach my $child(@children) {
						if($sex eq 'F') {
							# Check through all possible fathers, since there could be a biologial and
							# and adoptive one listed
							# FIXME: this assumes that the spouse is the biological father, which is not
							#	a good assumption to make
							my @candidates = $child->father();
							my $father;
							foreach (@candidates) {
								if($_ eq $spouse) {
									$father = $_;
									last;
								}
							}
							if((!defined($father)) || ($father ne $spouse)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						} else {
							my $mother = $child->mother();
							if((!defined($mother)) || ($mother ne $spouse)) {
								push @childrenunknownparent, $child;
								$numberofchildrenwiththisspouse--;
							} else {
								push @childrenofthisspouse, $child;
							}
						}
					}
					if(scalar(@childrenunknownparent) < $numberofchildren) {
						if(!$parentheses) {
							$bio .= ' (';
							$parentheses = 1;
						}
						$bio .= 'with whom ' . lcfirst($pronoun);
						if((!$all_children_are_alive) || (!$opts{'l'}) || ($yob && ($year > $yob + 100))) {
							$bio .= ' had ';
						} elsif((!$dateofdeath) && (!$dateofburial) && ($spouses[0]) && !$spouses[0]->death()) {
							$bio .= ' has had ';
						} else {
							$bio .= $dateofdeath || $dateofburial ? ' had ' : ' has ';
						}

						if($numberofchildrenwiththisspouse == 1) {
							if($all_children_are_alive) {
								$bio .= '1 surviving child, ';
							} else {
								$bio .= '1 child, ';
							}
						} else {
							if($all_children_are_alive) {
								$bio .= "$numberofchildrenwiththisspouse surviving children: ";
							} else {
								$bio .= "$numberofchildrenwiththisspouse children: ";
							}
						}
						if($numberofchildrenwiththisspouse == 1) {
							$bio .= $children[0]->given_names();
						} elsif($numberofchildrenwiththisspouse > 1) {
							# my $childnames = join(', ', map { $_->given_names() } @children);
							# substr($childnames, rindex($childnames, ', '), 2, ' and ');
							# print $childnames;
							$bio .= Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @childrenofthisspouse), {final_sep => ''});
						}
					}
				} else {
					my @spouse_occupations = $spouses[0]->get_value('occupation');
					while($spouse_occupations[0] && ($spouse_occupations[0] =~ /^scho(ol|lar)/i)) {
						shift @spouse_occupations;
					}
					while($spouse_occupations[0] && ($spouse_occupations[0] =~ /wife$/i)) {
						shift @spouse_occupations;
					}
					while($spouse_occupations[0] && ($spouse_occupations[0] =~ /Unpaid domestic duties/i)) {
						shift @spouse_occupations;
					}
					if($spouse_occupations[0]) {
						$bio .= ' (a ' . lc($spouse_occupations[0]);
						$parentheses = 1;
					}
				}
				if($parentheses) {
					$bio .= ')';
				} elsif(($dateofmarriage || $placeofmarriage) && $numberofchildren) {
					$bio .= ',';
				}
				if($placeofmarriage && $dateofmarriage &&
				   (($placeofbaptism and ($placeofmarriage eq $placeofbaptism)) ||
				    ($aod && $placeofbirth && ($placeofmarriage eq $placeofbirth)))) {
					$bio .= ' there ' .
						year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt);
				} else {
					$bio .= ' ' . year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt, must_predate => $death_dt) if($dateofmarriage);
					if($placeofmarriage) {
						my $args = {
							place => $placeofmarriage,
							person => $person,
							places_printed => \%places_printed
						};
						if($marriage && (my $address = $marriage->address())) {
							$args->{'address'} = $address;
						}
						my $p = place($args);
						$bio .= $p;
						$places_printed{$p} = 1;
					}
				}
				$bio .= "[$marriagecitation]" if($marriagecitation);
			} else {
				if(!$end_of_sentence) {
					$bio .= ' and';
				}
				$bio .= ' was married ';
				if(scalar(@spouses) == 2) {
					$bio .= 'twice';
				} else {
					$bio .= scalar(@spouses) . ' times';
				}
				my $all_marriages_have_date = 1;
				foreach my $spouse(@spouses) {
					my $date = get_value({ person => $spouse, value => 'marriage date' });
					if(!defined($date)) {
						if(my $marriage = ($spouse->get_record('marriage') || $spouse->get_record('fams marriage'))) {
							$date = $marriage->date();
						}
					}
					if(!date_to_datetime($date)) {
						$all_marriages_have_date = 0;
						last;
					}
				}
				if($all_marriages_have_date) {
					@spouses = Sort::Key::DateTime::dtkeysort {
						my $date;
						if(my $rec = $_->get_record('fams marriage')) {
							$date = $rec->date();
						}
						if((!defined($date)) && (my $rec = $_->get_record('marriage'))) {
							$date = $rec->date();
						}
						date_to_datetime(date => $date);
					} @spouses;
				}
				my $names;
				my $spouse_number = 0;
				my $previousplace;
				foreach my $spouse(@spouses) {
					# $names .= ', ' if($names);
					$names .= $spouse->as_string();
					my $dateofmarriage = get_value({ person => $spouse, value => 'marriage date' });
					if(!defined($dateofmarriage)) {
						if(my $marriage = ($spouse->get_record('marriage') || $spouse->get_record('fams marriage'))) {
							$dateofmarriage = $marriage->date();
						}
					}
					my $placeofmarriage = get_value({ person => $spouse, value => 'marriage place' });
					if(!defined($placeofmarriage)) {
						if(my $marriage = $spouse->get_record('marriage') || $spouse->get_record('fams marriage')) {
							$placeofmarriage = $marriage->place();
						}
					}
					if($placeofmarriage) {
						$placeofmarriage = place({ person => $spouse, place => $placeofmarriage, places_printed => \%places_printed });
						if($previousplace && ($placeofmarriage eq $previousplace)) {
							if($placeofmarriage =~ /^(.+?),/) {
								$placeofmarriage = " also$1";
							}
						} else {
							$previousplace = $placeofmarriage;
						}
					}

					my $printed_bracket = 0;
					if($dateofmarriage && $placeofmarriage) {
						$names .= ' (' . year({ string => $dateofmarriage }) .
							$placeofmarriage;
						$printed_bracket = 1;
					} elsif($placeofmarriage) {
						$placeofmarriage =~ s/^\s+//;
						$names .= " ($placeofmarriage";
						$printed_bracket = 1;
					} elsif($dateofmarriage) {
						$names .= ' (' . year({ string => $dateofmarriage });
						$printed_bracket = 1;
					}
					$spouse_number++;
					if((scalar(@spouses) == 2) && $all_marriages_have_date && ($spouse_number == 2) &&
					   (my $death_of_first_spouse = get_value({ person => $spouses[0], value => 'death date' }))) {
						if(datecmp($dateofmarriage, $death_of_first_spouse) > 0) {
							if($printed_bracket) {
								$names .= ', ';
							} else {
								$names .= '(';
								$printed_bracket = 1;
							}
							$names .= 'following the death of ' .
								$spouses[0]->as_string() . ' ' .
								year({
									person => $spouses[0],
									record => $death_of_first_spouse,
								});
						}
					}
					$names .= ')' if($printed_bracket);
					if($spouse_number == (scalar(@spouses) - 1)) {
						$names .= ' and ';
					} elsif($spouse_number < (scalar(@spouses) - 1)) {
						$names .= ', ';
					}
				}
				# substr($names, rindex($names, ', '), 2, ' and ');
				$bio .= ", to $names";
				$bio .= "[$marriagecitation]" if($marriagecitation);

				# Determine if all the children are from one marriage, since that's
				# easier to print.
				# FIXME:  handle where offspring are from more than one marriage
				if($numberofchildren) {
					my %childrenbyspouse;
					my $childrenseen = 0;
					my $unknown;
					foreach my $family ($person->fams()) {
						if($family->number_of_children() &&
						   ($spouse = ($sex eq 'M') ? $family->wife() : $family->husband())) {
							foreach my $child($person->children()) {
								$unknown = $child;
								foreach my $spouseschild($spouse->children()) {
									if($spouseschild eq $child) {
										$childrenbyspouse{$spouse}++;
										$childrenseen++;
										$unknown = undef;
										last;
									}
								}
							}
						}
					}
					my $parentofall;
					if($childrenseen < $numberofchildren) {
						# Unable to find the parent of all of the children.  This
						# may be the case where someone married more than once,
						# and has a child by a 3rd unknown (or unfound) person
						if($opts{'w'}) {
							if($opts{'f'}) {
								die $person->as_string() . ': one of the parents of ' . ($numberofchildren - $childrenseen) . ' children is not known';
							}
							if(($numberofchildren - $childrenseen) == 1) {
								if($unknown) {
									red_warning({ person => $person, warning => 'One of the parents of ' . $unknown->as_string() . ' is not known'});
								} else {
									red_warning({ person => $person, warning => 'One of the parents of 1 child is not known'});
								}
							} else {
								red_warning({ person => $person, warning => 'One of the parents of ' . ($numberofchildren - $childrenseen) . ' children is not known'});
							}
						}
					} else {
						foreach my $spouse(@spouses) {
							if($parentofall && $childrenbyspouse{$spouse}) {
								$parentofall = undef;
								last;
							}
							if($childrenbyspouse{$spouse}) {
								$parentofall = $spouse;
							}
						}
					}
					$bio .= ".  $pronoun " .
						($all_children_are_alive ? 'has ' : 'had ');
					if($numberofchildren == 1) {
						if($all_children_are_alive) {
							$bio .= '1 surviving child';
						} else {
							$bio .= '1 child';
						}
						if($childrenseen >= $numberofchildren) {
							if($parentofall) {
								$bio .= ' with ' . $parentofall->as_string();
							} else {
								complain({ person => $person, warning => 'BUG: parentofall not set when only one child' });
							}
						} else {
							$bio .= ' with an unknown ' . (($sex eq 'M') ? 'mother' : 'father');
						}
						$bio .= ', ' . $children[0]->given_names();
					} else {
						if($all_children_are_alive) {
							$bio .= "$numberofchildren surviving children";
						} else {
							$bio .= "$numberofchildren children";
						}
						my $childnames;
						if($parentofall) {
							if($numberofchildren == 2) {
								$bio .= ', both with ' . $parentofall->as_string();
							} else {
								$bio .= ', all with ' . $parentofall->as_string();
							}
							$childnames = join(', ', map { $_->given_names() } @children);
						} elsif($sex eq 'M') {
							# FIXME: children from the same parent should be listed together
							$childnames = join(', ', map { $_->given_names() . ($_->mother() ? (' (with ' . $_->mother()->given_names() . ')') : '') } @children);
						} else {
							$childnames = join(', ', map { $_->given_names() . ($_->father() ? (' (with ' . $_->father()->given_names() . ')') : '') } @children);
						}
						substr($childnames, rindex($childnames, ', '), 2, ' and ');
						$bio .= ": $childnames";
					}
				}
			}
			$end_of_sentence = 0;
		} elsif($numberofchildren) {
			if($end_of_sentence) {
				$bio .= " $pronoun";
			}
			$bio .= ' had ' .
				(($numberofchildren == 1) ? '1 child, ' : "$numberofchildren children, ");
			if($numberofchildren == 1) {
				$bio .= $children[0]->given_names();
			} else {
				my $childnames = join(', ', map { $_->given_names() } @children);
				substr($childnames, rindex($childnames, ', '), 2, ' and ');
				$bio .= $childnames;
			}
			$end_of_sentence = 0;
		}

		if(scalar(@childrenunknownparent)) {
			$bio .= '.  ' if(!$end_of_sentence);
			$bio .= "$pronoun ";
			if(scalar(@children) > scalar(@childrenunknownparent)) {
				$bio .= 'also ';
			}
			$bio .= 'had ' . scalar(@childrenunknownparent) . ' ';
			if(scalar(@childrenunknownparent) == 1) {
				$bio .= 'child, ';
			} else {
				$bio .= 'children, ';
			}
			$bio .= Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @childrenunknownparent), {final_sep => ''}) .
				', whose ' .
				(($sex eq 'F') ? 'father' : 'mother') .
				' is unknown';
			$end_of_sentence = 0;
		}

		if($same_occupation_as_father) {
			$bio .= '. ' if(!$end_of_sentence);
			$bio .= ' Like ' . ($pronoun eq 'He' ? 'his' : 'her' ) . ' father, ' . lcfirst($pronoun) .
				(is_alive(person => $person) ? ' is a' : ' was a');
			if($same_occupation_as_father =~ /^[aeiou]/i) {
				$bio .= 'n';
			}
			$bio .= ' ' . lc($same_occupation_as_father) . '. ';
			$end_of_sentence = 1;
		}

		my $printed_residence = 0;
		my %citationnotes;

		if($opts{'w'}) {
			my $index = 0;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
					}
				}
				if(ref($event) eq 'Gedcom::Record') {
					my $type = $event->type();
					if(!defined($type)) {
						red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
						next;
					}

					if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939')) {
						if(!$dateofbirth) {
							complain({ person => $person, warning => 'Census information not used to approximate a date of birth' });
						}
					}
				}
			}
		}

		if(scalar(@residences)) {
			# FIXME: handle duplicate locations better
			my @residencelist;
			my %residencecitations;

			# This is an attempt to handle
			# https://github.com/pjcj/Gedcom.pm/issues/13
			my $index = 0;
			foreach my $residence(@residences) {
				$index++;
				if(!ref($residence)) {
					my $r = $person->tag_record('EVEN', $index);
					if(ref($r) eq 'Gedcom::Record') {
						$residence = $r;
					} else {
						$r = $person->record(['residence', $index]);
						if(ref($r) eq 'Gedcom::Record') {
							$residence = $r;
						} else {
							red_warning({ person => $person, warning => "Residence record is just description ($residence), infomation has been lost" });
						}
					}
				}
				if(ref($residence) eq 'Gedcom::Record') {
					my $place = $residence->place();
					if(my $address = $residence->address()) {
						if(ref($address) eq 'Gedcom::Record') {
							$place = getaddress($address);
						} elsif($place) {
							$place = "$address, $place";
						} elsif($opts{'f'}) {
							die $person->string(), ": address set to $address but place is empty";
						} else {
							red_warning({
								person => $person,
								warning => "address set to $address but place is empty"
							});
						}
					}
					if(defined($place)) {
						if(my $dor = $residence->date()) {
							if($placeofbirth && $dob && ($dor eq $dob)) {
								next;
							}
							if($placeofmarriage && $dateofmarriage && ($dor eq $dateofmarriage)) {
								next;
							}
						}
						push @residencelist, $residence;
						if(my $src = $residence->source()) {
							$src = get_source({ gedcom => $ged, person => $person, source => $src}) unless ref($src);
							my $note = notes(record => $residence);
							foreach my $c(@birthcitations) {
								if($src eq $citations{$c}) {
									$residencecitations{$residence} = $c;
									if($note) {
										$citationnotes{$c} = $note;
									}
									last;
								}
							}
							unless($residencecitations{$residence}) {
								if($deathcitations[0] && ($src eq $citations{$deathcitations[0]})) {
									$residencecitations{$residence} = $deathcitations[0];
									if($note) {
										$citationnotes{$deathcitations[0]} = $note;
									}
								} else {
									$residencecitations{$residence} = ++$citationcount;
									$citations{$citationcount} = $src;
									if($note) {
										$citationnotes{$citationcount} = $note;
									}
								}
							}
						}
					} elsif(my $dor = $residence->date()) {
						if(my $type = $residence->type()) {
							if($type ne 'Military service') {
								red_warning({ person => $person, warning => "Residence record for $dor contains no location" });
							}
						}
					} else {
						red_warning({ person => $person, warning => 'Residence record contains no location' });
					}
				}
			}

			# TODO: See RT110333

			# Sort residences chronologically
			# FIXME: This messes citations
			my $all_residences_have_date = 1;
			foreach my $residence(@residencelist) {
				my $date = $residence->date();
				if(!$date) {
					complain({ person => $person, warning => 'Contains a residence' . place(record => $residence) . ' without a date' });
					$all_residences_have_date = 0;
					last;
				}
				$date = $date_parser->parse(date => $date);
				if(!defined($date)) {
					complain({ person => $person, warning => "Can't parse date '$date'" });
					$all_residences_have_date = 0;
					last;
				}
				if(scalar(@{$date}) == 0) {
					# e.g. "Apr/May/Jun 2016"
					$all_residences_have_date = 0;
					last;
				}
			}
			if($all_residences_have_date) {
				@residencelist = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @residencelist;

			}
			my $count = 0;
			my $have_printed = 0;
			my $prev_residence;
			my $spdeath_dt;
			if($spouses[0]) {
				$spdeath_dt = date_to_datetime(date => get_value({ person => $spouses[0], value => 'death date' }));
			}
			my $print_year_only;	# used when printing a range, e.g. 1871-1891
			my $printed_following_message;
			foreach my $residence(@residencelist) {
				my $rdate = $residence->date();
				if(($count == 0) || !places_are_the_same({ person => $person, first => $residence, second => $residencelist[$count - 1] })) {
					if($birth && $dob && $rdate && ($rdate eq $dob) &&
					   places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						# This residence record is for the place of birth, which is
						# printed elsewhere
						$count++;
						next;
					}
					if(!$have_printed) {
						$bio .= '. ' unless($end_of_sentence);
						if((scalar(@residencelist) == 1) && $rdate) {
							$bio .= ' ' . ucfirst(year({ person => $person, date => $rdate, circa => 'About' })) .
								', ' . lcfirst($pronoun) . ' was living';
						} else {
							if($opts{'B'}) {
								if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
									$text->textend();

									$pdfpage = PDFPage->new();

									$text = $pdfpage->text();
									$text->font($params{'font'}, 12);
									pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
								}
								$bio = '';
							} else {
								$bio .= "\n\t";
							}
							$bio .= 'During ' .
								lc($person->possessive()) .
								' life, ' . lcfirst($pronoun) . ' was living';
						}
						$have_printed = 1;
					}
					if($birth && places_are_the_same({ person => $person, first => $birth, second => $residence})) {
						$bio .= ' at ' . ($person->pronoun() eq 'She' ? 'her' : 'his')
								. ' birthplace';
					} else {
						my $p = place({
							person => $person,
							record => $residence,
							places_printed => \%places_printed
						});
						if($residence->type() && ($residence->type() eq 'Hospitalisation')) {
							$bio .= ' in hospital';
						}

						$bio .= $p;
						$places_printed{$p} = 1;
					}
				}
				# Citation residence notes print later
				if($rdate) {	# residence has a date?
					if($opts{'w'} && ($rdate =~ /(\d{3,4})$/)) {
						my $yoe = $1;
						if($yod) {
							if($yoe > $yod) {
								complain({
									person => $person,
									warning => "Year of residence $yoe is after the year of death $yod"
								});
							} elsif($death_dt && (my $rdate_dt = date_to_datetime($rdate))) {
								# FIXME: If $rdate is a date range, should check both dates in the range
								if($rdate_dt > $death_dt) {
									complain({
										person => $person,
										warning => "Date of residence $rdate is after date of death " . $death_dt->strftime('%x')
									});
								}
							}
						}
						if($yob && (($yoe - $yob) <= 10)) {
							my $found_parent = 0;
							if($mother) {
								foreach my $residence(get_all_residences($mother)) {
									my $date = $residence->date();
									if(defined($date) && ($date =~ /(\d{3,4})$/)) {
										if($1 == $yoe) {
											$found_parent = $residence;
											last;
										}
									}
								}
							}
							if($father && !$found_parent) {
								foreach my $residence(get_all_residences($father)) {
									my $date = $residence->date();
									if(defined($date) && ($date =~ /(\d{3,4})$/)) {
										if($1 == $yoe) {
											$found_parent = $residence;
											last;
										}
									}
								}
							}
							if((!$mother) && !$father) {
								# People not related by blood tend not to have been researched
								if($relationship) {
									complain({ person => $person, warning => 'Census information not used to determine a parent' });
								}
							} elsif(!$found_parent) {
								# FIXME: both parents could be dead
								complain({ person => $person, warning => "Residence information in $yoe, but no residence information found for either parent" });
							}	# TODO: else warn if both parents locations are different
						} elsif($numberofchildren && ($rdate !~ /^bet\s/i)) {
							# Look if a young child isn't with this parent
							foreach my $child(@children) {
								my $cyob = get_value({ person => $child, value => 'birth date' });
								next if(!defined($cyob));
								next if(datecmp($cyob, $rdate) >= 0);	# Child was not born yet
								if($cyob =~ /(\d{3,4})\s*$/) {
									$cyob = $1;
								}
								next if(($yoe - $cyob) > 10);	# Over 10 years old
								if(my $cyod = get_value({ person => $child, value => 'death date' })) {
									next if(datecmp($cyod, $rdate) <= 0);	# Child was dead by this event
								}

								my $missing_child = 1;
								foreach my $event(get_all_residences($child)) {
									my $edate = $event->date();
									if($edate && ($edate !~ /^bet\s/i) && (datecmp($edate, $rdate) >= 0)) {
										$missing_child = 0;
										last;
									}
								}
								if($missing_child) {
									if($firstname) {
										complain({ person => $child, warning => "Parent $firstname is listed in the residence for $rdate, but this child is not" });
									} else {
										complain({ person => $child, warning => "Parent is listed in the residence for $rdate, but this child is not" });
									}
								}
							}
						}
					}
					if(scalar(@residencelist) > 1) {
						my $this_date = year({ person => $person, date => $rdate });
						if($prev_residence && (year(record => $prev_residence) eq $this_date)) {
							if(place(record => $prev_residence) ne place(record => $residence)) {
								complain({ person => $person, warning => "Two residence records for $rdate differ in location" });
							}
						} else {
							if($print_year_only) {
								if($count == (scalar(@residencelist) - 1)) {
									$bio .= $rdate;
									# $print_year_only = 0;
								}
							} else {
								$bio .= " $this_date";
							}
							$prev_residence = $residence;
						}
					}
					if($spdeath_dt && (!$printed_following_message) && (my $rdate_dt = date_to_datetime($rdate))) {
						if($rdate_dt > $spdeath_dt) {
							# Living with a child following death of spouse?
							CHILD: foreach my $child(@children) {
								my @cevents = $child->event();
								my $index = 0;
								EVENT: foreach my $event(@cevents) {
									$index++;
									if(!ref($event)) {
										my $e = $child->tag_record('EVEN', $index);
										if(ref($e) eq 'Gedcom::Record') {
											$event = $e;
										} else {
											# red_warning({ person => $child, warning => "Event record is just description ($event), infomation has been lost" });
											next EVENT;
										}
									}
									my $type = $event->type();

									if(($type !~ /^Census U[KS] (\d{4})$/) && ($type ne 'Register UK 1939')) {
										next EVENT;
									}
									if((ref($event) eq 'Gedcom::Record') &&
									   $event->date() && ($event->date() eq $rdate) &&
									   places_are_the_same({ person => $child, first => $residence, second => $event })) {
										$bio .= ' when ' .
											lcfirst($person->pronoun()) .
											' was living with ' .
											lcfirst($person->possessive()) .
											(($child->sex() eq 'F') ? ' daughter ' : ' son ') .
											$child->given_names() .
											' following the death of ' .
											(($sex eq 'M') ? 'his wife ' : 'her husband ') .
											year(date => get_value({ person => $spouses[0], value => 'death date' }));
										$spdeath_dt = undef;
										last CHILD;
									}
								}
							}
							if($spdeath_dt) {
								# Outlived spouse, but not living with a child
								$bio .= ' following the death of ' .
									($person->pronoun() eq 'She' ? 'her' : 'his') .
									(($sex eq 'M') ? ' wife ' : ' husband ') .
									year(date => get_value({ person => $spouses[0], value => 'death date' }));
							}
							$printed_following_message = 1;
						}
					}
					# Find if they are an adult living with an adult sibling or in-law
					if($all_residences_have_date && scalar(@siblings) && $birth_dt) {
						my $printed_sibling = 0;
						my $r = $residence;
						next if($r->date() ne $rdate);
						my $place = place({ person => $person, record => $r });
						my $first = 1;

						my $bdiff = $dfn->parse_datetime($rdate) - $birth_dt;

						foreach my $sibling(@siblings) {
							if(my $ss = $sibling->spouse()) {
								next if($bdiff->in_units('years') < 20);
								# If they are living with an in-law, assume both are adults
								my @ssr = get_all_residences(person => $ss);
								foreach my $ssr(@ssr) {
									if(my $d = $ssr->date()) {
										next if($d ne $rdate);
										if(my $ssp = place({ person => $ss, record => $ssr })) {
											if($ssp eq $place) {
												if($first) {
													$bio .= ' with ' . ($person->pronoun() eq 'She' ? 'her' : 'his') .
														' ' .
														(($ss->sex() eq 'F') ? 'sister-in-law, ' : 'brother-in-law, ') .
														$ss->as_string();
														$first = 0;
												} else {
													# FIXME: If possible, should say
													#	sisters-in-law or
													#	brothers-in-law
													$bio .= ' and ' .
														(($ss->sex() eq 'F') ? 'sister-in-law, ' : 'brother-in-law, ') .
														$ss->as_string();
													}
												last;
											}
										}
									}
								}
							}
							next if($bdiff->in_units('years') < 40);
							# Safe to assume both are adults at this time
							my @sr = get_all_residences(person => $sibling);
							foreach my $sr(@sr) {
								my $sdate = $sr->date();
								next if(!defined($sdate));
								next if($sdate ne $rdate);
								if(place({ person => $sibling, record => $sr }) eq $place) {
									$bio .= ' with ' . ($person->pronoun() eq 'She' ? 'her' : 'his') .
										' ' .
										(($sibling->sex() eq 'F') ? 'sister, ' : 'brother, ') .
										$sibling->given_names();
									$printed_sibling = 1;
									last;
								}
							}
						}
						# FIXME: only checks when there are @siblings
						if($mother && ($bdiff->in_units('years') >= 30)) {
							my @mr = get_all_residences(person => $mother);
							foreach my $mr(@mr) {
								my $mdate = $mr->date();
								next if(!defined($mdate));
								next if($mdate ne $rdate);
								if(place({ person => $mother, record => $mr }) eq $place) {
									$bio .= ($printed_sibling ? ' and ' : ' with ') .
										($person->pronoun() eq 'She' ? 'her' : 'his') .
										' mother, ' .
										$mother->given_names();
									$printed_sibling = 1;
									last;
								}
							}
						}
						if($father && ($bdiff->in_units('years') >= 30)) {
							my @fr = get_all_residences(person => $father);
							foreach my $fr(@fr) {
								my $fdate = $fr->date();
								next if(!defined($fdate));
								next if($fdate ne $rdate);
								if(place({ person => $father, record => $fr }) eq $place) {
									$bio .= ($printed_sibling ? ' and ' : ' with ') .
										($person->pronoun() eq 'She' ? 'her' : 'his') .
										' father, ' .
										$father->given_names();
									last;
								}
							}
						}
						if($spouse && $marriage_dt && (my $rdate_dt = date_to_datetime($rdate))) {
							if($marriage_dt > $rdate_dt) {
								my @sr = get_all_residences(person => $spouse);
								foreach my $sr(@sr) {
									my $sdate = $sr->date();
									next if(!defined($sdate));
									next if($sdate ne $rdate);
									if(place({ person => $spouse, record => $sr }) eq $place) {
										$bio .= ($printed_sibling ? ' and ' : ' with ') .
											($person->pronoun() eq 'She' ? 'her future husband, ' : 'his future wife, ') .
											$spouse->given_names();
										last;
									}
								}
							}
						}
					}
				}
				if((!($opts{'c'} && $residence->source())) && (my $notes = notes({ record => $residence }))) {
					$notes =~ s/\.$//;
					$notes = lcfirst($notes);
					$bio .= " ($notes)";
				} elsif($opts{'c'}) {
					if($residencecitations{$residence}) {
						$bio .= '[' . $residencecitations{$residence} . ']';
					}
					if($residence->place() &&
					  (!$rdate) &&
					  ($count <= (scalar(@residencelist) - 1)) &&
					  ($residencecitations{$residence})) {
						my $peek = $residencelist[$count + 1];
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							if($residencecitations{$peek}) {
								$bio .= '[' . $residencecitations{$peek} . ']';
							}
						}
					}
				}
				$count++;
				if(($count == 1) && (scalar(@residencelist) == 2)) {
					if($print_year_only) {
						$bio .= $rdate;
						$print_year_only = 0;
					}
					$bio .= ' and';
				} else {
					my $peek = $residencelist[$count];
					if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
						$peek = $residencelist[$count + 1];
						if($peek && places_are_the_same({ person => $person, first => $residence, second => $peek })) {
							if((!$opts{'c'}) && $rdate && ($rdate =~ /^\d{4}$/) && $peek->date() && ($peek->date() =~ /^\d{4}$/)) {
								if(!$print_year_only) {
									$bio .= '-';
									$print_year_only = 1;
								}
							} else {
								if($print_year_only && $rdate) {
									$bio .= $rdate;
									$print_year_only = 0;
								}
								$bio .= ',';
							}
						} elsif(!$print_year_only) {
							$bio .= ' and';
						}
					} elsif($count == (scalar(@residencelist) - 1)) {
						if($print_year_only) {
							$bio .= $rdate;
							$print_year_only = 0;
						}
						$bio .= '; and';
					} elsif($count < (scalar(@residencelist) - 1)) {
						if($print_year_only) {
							$bio .= $rdate;
							$print_year_only = 0;
						}
						$bio .= ';';
					}
				}
				$printed_residence = 1;
			}

			if($printed_residence) {
				$bio .= '. ';
				$end_of_sentence = 1;
			}
		}

		my $all_events_have_date = 1;
		foreach my $event(@events) {
			if((ref($event) ne 'Gedcom::Record') || !$event->date()) {
				$all_events_have_date = 0;
				last;
			}
			my $date = $event->date();
			if(($date !~ /^\d/) || ($date =~ /[a-z]$/i) ||
			   ($date =~ /[\/\-]/) || !date_parser_cached(date => $date)) {
				$all_events_have_date = 0;
				last;
			}
			if(!date_parser_cached(date => $date)) {
				if($opts{'f'}) {
					die $person->as_string(),
						": Event has an invalid date of $date";
				}
				if($opts{'w'}) {
					red_warning({
						person => $person,
						warning => "Event has an invalid date of $date"
					});
				}
				$all_events_have_date = 0;
				last;
			}
		}
		if($all_events_have_date) {
			@events = Sort::Key::DateTime::dtkeysort { $dfn->parse_datetime(@{$date_parser->parse(date => $_->date())}[0]->{'canonical'}) } @events;
		}
		if((scalar(@events) == 2) &&
		   (ref($events[0]) eq 'Gedcom::Record') &&
		   (ref($events[1]) eq 'Gedcom::Record') &&
		   ((($events[0]->type() eq 'Arrival') && ($events[1]->type() eq 'Departure')) ||
		    (($events[1]->type() eq 'Arrival') && ($events[0]->type() eq 'Departure')))) {
			# Simple case - one journey made
			$bio .= '. ' if(!$end_of_sentence);
			$end_of_sentence = 1;

			my $arrival = ($events[0]->type() eq 'Arrival') ? $events[0] : $events[1];
			my $departure = ($events[0]->type() eq 'Departure') ? $events[0] : $events[1];
			my $yod;
			my $yoa;
			my $dod = $departure->date();
			my $doa = $arrival->date();
			my $only_have_departure_year;
			if($doa && $dod && ($doa =~ /(\d{3,4})/)) {
				$yoa = $1;
				$doa =~ s/\s?\d{3,4}//;
				if($dod =~ /(\d{3,4})/) {
					$yod = $1;
					$dod =~ s/\s?\d{3,4}//;
					if($dod =~ /^\d/) {
						$dod = "on $dod";
					} else {
						$dod = "during $yod";
						$only_have_departure_year = 1;
					}
					if($doa =~ /^\d/) {
						$doa = "on $doa";
					} else {
						$doa = "during $doa";
					}
				}
			}
			if($departure || !$doa) {
				if($yod && $yoa && ($yod == $yoa)) {
					$bio .= "During $yod " . lc($person->pronoun());
				} else {
					$bio .= $person->pronoun();

					# $yod = year({ person => $person, record => $departure });
					# $yoa = year({ person => $person, record => $arrival });
				}

				if($ENV{'LANG'} =~ /^en_US/) {
					$bio .= ' traveled';
				} else {
					$bio .= ' travelled';
				}

				if(defined($departure->place())) {
					$bio .= ' from ' . $departure->place();
				} else {
					if($opts{'f'}) {
						die $person->as_string() . ': departure record has no location';
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => 'Departure record has no location' });
					}
				}
				if(defined($arrival->place())) {
					$bio .= ' to ' . $arrival->place();
				} else {
					if($opts{'f'}) {
						die $person->as_string() . ': arrival record has no location';
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => 'Arrival record has no location' });
					}
				}

				if(defined($dod) && !$only_have_departure_year) {
					$bio .= ", departing $dod and";
				}

				$bio .= " arriving $doa. ";
			} else {
				$bio .= ucfirst(year({ person => $person, record => $arrival })) .
					', ' . lcfirst($person->pronoun()) .
					' arrived' .
					place({ person => $person, record => $arrival }) . '. ';
			}
			$end_of_sentence = 1;
		} elsif(scalar(@events) == 1) {
			$bio .= '. ' if(!$end_of_sentence);
			$end_of_sentence = 1;

			my $event = $person->event();
			if(!ref($event)) {
				my $e = $person->tag_record('EVEN');
				if(ref($e) eq 'Gedcom::Record') {
					$event = $e;
				} else {
					red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
					$bio .= ' ' . ucfirst($event) . '. ';
				}
			}
			if(ref($event) eq 'Gedcom::Record') {
				my $type = $event->type();
				if(!defined($type)) {
					red_warning({ person => $person, warning => "Can't determine type of event, or the event type is empty" });
				} elsif($type eq 'Arrival') {
					$bio .= ' ' . $person->pronoun() . ' arrived';
					if(my $p = place({ person => $person, record => $events[0] })) {
						$bio .= $p;
					} else {
						complain({ person => $person, warning => 'Arrival record has no place' });
					}
					if(my $y = year({ person => $person, record => $events[0] })) {
						$bio .= " $y";
					} else {
						complain({ person => $person, warning => 'Arrival record has no date' });
					}
					if(my $spouse = $person->spouse()) {
						foreach my $sevent($spouse->event()) {
							if(ref($sevent) eq 'Gedcom::Record') {
								my $type = $event->type();
								if(!defined($type)) {
									red_warning({ person => $spouse, warning => "Can't determine type of event, or the event type is empty" });
								} elsif($sevent->place() && ($type eq 'Arrival') &&
								   $event->date() && $sevent->date() &&
								   ($event->date() eq $sevent->date()) &&
								   ($event->place() eq $sevent->place())) {
									$bio .= ' with ' .
										lcfirst($person->possessive()) . ' ' .
										(($sex eq 'M') ? 'wife' : 'husband') .
										' ' . $spouse->given_names();
								}
							}
						}
					}
					if(my $notes = notes({ record => $event })) {
						$notes = lcfirst($notes);
						$notes =~ s/\.$//;
						$bio .= " ($notes)";
					}
					$bio .= '. ';
				} elsif($type eq 'Departure') {
					$bio .= ' ' . $person->pronoun();
					if($ENV{'LANG'} =~ /^en_US/) {
						$bio .= ' traveled';
					} else {
						$bio .= ' travelled';
					}
					my $place = place({ person => $person, record => $events[0] });
					$place =~ s/^\sin/ from/;
					$bio .= "$place " .
						year({ person => $person, record => $events[0] });
					if(my $notes = notes({ record => $event })) {
						$notes = lcfirst($notes);
						$bio .= " ($notes)";
					}
					$bio .= '. ';
				} elsif($type eq 'Military service') {
					$bio .= '. ' if(!$end_of_sentence);
					$bio .= " $pronoun served in the military";
					if(my $place = place({ person => $person, record => $event })) {
						$bio .= $place;
					}
					if(my $date = year(record => $event)) {
						$bio .= " $date";
					}

					if(my $notes = notes(record => $event)) {
						$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
						$notes =~ s/[\s\.]+$//;
						$bio .= " ($notes)";
					}
					$end_of_sentence = 0;
				} elsif(($type !~ /^Census U[KS] (\d{4})$/) &&
					($type ne 'Race') &&
					($type ne 'Custom Marriage') &&
					($type ne 'Register UK 1939')) {

					red_warning({ person => $person, warning => "Unhandled event type: $type" });
					if(my $notes = notes(record => $event)) {
						$notes = ucfirst($notes);
						$bio .= " ($notes)";
						$end_of_sentence = 0;
					}
				}
			}
		} else {
			my $mentioned_military;
			my $index = 0;
			my $previous;
			my $prev_type;
			foreach my $event(@events) {
				$index++;
				if(!ref($event)) {
					my $e = $person->tag_record('EVEN', $index);
					if(ref($e) eq 'Gedcom::Record') {
						$event = $e;
					} else {
						red_warning({ person => $person, warning => "Event record is just description ($event), infomation has been lost" });
						$bio .= ' ' . ucfirst($event) . '. ';
					}
				}
				if(ref($event) eq 'Gedcom::Record') {
					my $type = $event->type();
					if($type eq 'Military service') {
						if(!$mentioned_military) {
							$bio .= '. ' if(!$end_of_sentence);
							$bio .= " $pronoun served in the military";
							if(my $place = place({ person => $person, record => $event, allow_empty => 1 })) {
								$bio .= $place;
							}
							if(my $date = year(record => $event)) {
								$bio .= " $date";
							}
							$mentioned_military = 1;
						}

						if(my $notes = notes(record => $event)) {
							$notes = lcfirst($notes) unless($notes =~ /^(RAF|Royal Navy)/);
							$notes =~ s/[\s\.]+$//;
							$bio .= " ($notes)";
						}
						$end_of_sentence = 0;
					} elsif($type eq 'Arrival') {
						if(!defined($event->place())) {
							complain({ person => $person, warning => 'Arrival record without destination' });
							next;
						}
						if($events[$index] && ($events[$index]->type() eq 'Departure') && $event->date()) {
							if($events[$index]->date()) {
								$previous = $event;
								$prev_type = 'Arrival';
								# FIXME: not all notes will be printed
								next;
							}
						}
						if($previous) {
							if($prev_type eq 'Departure') {
								$bio .= journey({ person => $person, arrival => $event, departure => $previous });
							} else {
								# Two arrival records, put into one sentence for improved readability
								my $date1 = year({ record => $previous });
								my $date2 = year({ record => $event });
								my $year1;
								my $year2;
								if($date1 =~ /(.*)\s?(\d{4})$/) {
									$date1 = $1;
									$year1 = $2;
									$date1 =~ s/,\s//;
								}
								if($date2 =~ /(.*)\s?(\d{4})$/) {
									$date2 = $1;
									$year2 = $2;
									$date2 =~ s/,\s//;
								}
								$bio .= '. ' if(!$end_of_sentence);
								$bio .= ' ';
								if(defined($year1) && defined($year2) && ($year1 == $year2)) {
									if($date1 eq 'in ') {
										$date1 = '';
									} else {
										$date1 = " $date1";
									}
									$bio .= "During $year1 " . lcfirst($pronoun) . ' arrived' .
										place({ person => $person, record => $previous }) .
										"$date1 and" .
										place({ person => $person, record => $event, nopreposition => 1 }) .
										" $date2. ";
								} else {
									$bio .= ucfirst(year({ person => $person, record => $previous })) .
										' ' . lcfirst($person->pronoun()) .
										' arrived' .
										place({ person => $person, record => $previous }) .
										' and ' .
										year({ person => $person, record => $event }) .
										' ' . lcfirst($pronoun) .
										' arrived' .
										place({ person => $person, record => $event });
								}
							}
							$previous = undef;
						} elsif(my $place = place({ person => $person, record => $event })) {
							if(my $year = year({ person => $person, record => $event })) {
								if($end_of_sentence) {
									$bio .= ' ' . ucfirst($year);
								} else {
									$bio .= $year;
								}
								if(my $notes = notes(record => $event)) {
									$notes = lcfirst($notes);
									$bio .= " ($notes)";
								}
								$bio .= ' ' . lcfirst($person->pronoun()) . " arrived$place";
							} else {
								complain({ person => $person, warning => "Can't determine $type date" });
							}
						} else {
							complain({ person => $person, warning => "Can't determine $type location" });
						}
						$bio .= '. ';
						$end_of_sentence = 1;
					} elsif($type eq 'Departure') {
						if(!defined($event->place())) {
							complain({ person => $person, warning => 'Departure record without destination' });
							next;
						}
						if($events[$index] && (ref($events[$index]) eq 'Gedcom::Record') && ($events[$index]->type() eq 'Arrival') && $event->date()) {
							if($events[$index]->date()) {
								$previous = $event;
								$prev_type = 'Departure';
								# FIXME: not all notes will be printed
								next;
							}
						}
						if($previous) {
							if($prev_type eq 'Arrival') {
								$bio .= journey({ person => $person, arrival => $previous, departure => $event });
							}
							$previous = undef;
						} else {
							$bio .= ' ' . $person->pronoun();
							if($ENV{'LANG'} =~ /^en_US/) {
								$bio .= ' traveled';
							} else {
								$bio .= ' travelled';
							}
							my $place = place({ person => $person, record => $event });
							$place =~ s/^\sin/ from/;
							if($event->date()) {
								$bio .= "$place " .
									year({ person => $person, record => $event });
							} else {
								$bio .= $place;
							}
							if(my $notes = notes(record => $event)) {
								$notes = lcfirst($notes);
								$bio .= " ($notes)";
							}
						}
						$bio .= '. ';
						$end_of_sentence = 1;
					} elsif(($type !~ /^Census U[KS] (\d{4})$/) &&
						($type ne 'Register UK 1939') &&
						($type ne 'Race') &&
						($type ne 'Hospitalisation')) {
						red_warning({ person => $person, warning => "Unknown event type: $type" });
						if(my $notes = notes(record => $event)) {
							$notes =~ s/\.$//;
							my $date = year(record => $event);
							if($end_of_sentence) {
								if($date) {
									$bio .= ' ' . ucfirst($notes) . " $date. ";
								} else {
									$bio .= ' ' . ucfirst($notes) . '. ';
								}
							} else {
								$notes = lcfirst($notes);
								if($date) {
									$bio .= " ($date, $notes)";
								} else {
									$bio .= " ($notes)";
								}
							}
						}
					}
				}
			}
		}

		if(my $profile_object = $person->tag_record('_MILT')) {
			# $person->resolve_xref($profile_object->value());
			if(my $value = $profile_object->get_value()) {
				$bio .= '. ' if(!$end_of_sentence);
				$value =~ s/[\s\.]+$//;
				$bio .= " $pronoun served in the military ($value). ";
				$end_of_sentence = 1;
			}
		}

		if($placeofburial || $dateofburial) {
			if($aod || ((!$dateofdeath) && !$placeofdeath)) {
				$bio .= '. ' if(!$end_of_sentence);
				if($dateofburial) {
					$bio .= " $pronoun was buried";
					if($placeofburial) {
						if($placeofbirth && ($placeofburial eq $placeofbirth)) {
							if(my $address = $burial->address()) {
								$bio .= " at $address";
							}
							$bio .= ' in ' .
								lcfirst($person->possessive()) .
								' home town of ';
							my $city = $placeofburial;
							if($city =~ /^(.+?),/) {
								$bio .= $1;
							} else {
								$bio .= place({ person => $person, place => $placeofburial });
							}
						} else {
							my $opts = {
								person => $person,
								place => $placeofburial,
								there => $placeofdeath,
								places_printed => \%places_printed,
								must_postdate => $birth_dt
							};
							if(my $address = $burial->address()) {
								$opts->{'address'} = $address;
							}
							$bio .= place($opts);
						}
					}
					$bio .= ' ' . year({ person => $person, date => $dateofburial });
					if(my $b = notes({ record => $burial, paragraph => 0 })) {
						$b =~ tr/\r//;
						$bio .= " ($b)";
					}
				} elsif($placeofbirth && ($placeofburial eq $placeofbirth)) {
					$bio .= " $pronoun was buried";
					if(my $address = $burial->address()) {
						$bio .= " at $address";
					}
					$bio .= ' in ' . lcfirst($person->possessive()) .
						' home town of ';
					my $city = $placeofburial;
					if($city =~ /^(.+?),/) {
						$bio .= $1;
					} else {
						$bio .= place({ person => $person, place => $placeofburial });
					}
				} else {
					$bio .= " $pronoun is buried" .
						place({ person => $person, record => $burial, places_printed => \%places_printed, there => $placeofmarriage });
				}
				$end_of_sentence = 0;
			} elsif($dateofdeath || $placeofdeath) {
				$bio .= '.' if(!$end_of_sentence);
				if($opts{'B'}) {
					if($bio) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = '';
					}
				} else {
					$bio .= "\n\t";
				}
				$bio .= "$pronoun died";
				if($dateofdeath) {
					$bio .= ' ' . year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				}
				if($placeofdeath && (my $p = place({ person => $person, record => $death, places_printed => \%places_printed }))) {
					$bio .= $p;
					$places_printed{$p} = 1;
				}
				$bio .= "[$_]" foreach(List::Util::uniq(sort @deathcitations));
				# Print notes about the death, if any
				if(my $d = notes({ person => $person, record => $death })) {
					$d =~ tr/\r//;
					$d =~ tr/\n/ /;
					$d =~ s/\.$//;
					$d = lcfirst($d) unless($d =~ /^[A-Z]{2}/);
					$bio .= " ($d)";
				}
				my $opts = {
					person => $person,
					place => $placeofburial,
					there => $placeofdeath,
					places_printed => \%places_printed,
					must_postdate => $birth_dt,
				};
				my $address;
				if($address = get_value({ person => $person, value => 'burial address' })) {
					$opts->{'address'} = $address;
				}
				if($dateofburial) {
					$bio .= ' and was buried';
					if($placeofburial) {
						if(defined($placeofdeath) && ($placeofburial eq $placeofdeath) && !$death->address()) {
							$bio .= ' there';
							if($address) {
								$bio .= " at $address";
							}
						} else {
							$bio .= place($opts);
						}
					}
					my $must_postdate;
					if($death_dt) {
						$must_postdate = $death_dt;
					} elsif(!defined($dateofdeath)) {
						complain({
							person => $person,
							warning => 'Date of burial is known but not of death, suggest adding "Abt. YEAR"'
						});
					} elsif($dateofdeath =~ /^(Abt|ca?)\.?\s*(.+)/i) {
						my $d = $2;
						if($d !~ /^\d/) {
							$must_postdate = date_to_datetime("1 $d");
						} else {
							$must_postdate = date_to_datetime($d);
						}
					}
					$bio .= ' ' . year({ person => $person, date => $dateofburial, must_postdate => $must_postdate });
				} elsif($placeofdeath && ($placeofburial eq $placeofdeath) && $burial->address() && (!$death->address())) {
					$bio .= ' and is buried there at ' . $burial->address();
				} else {
					$bio .= ' and is buried' . place($opts);
				}
				if(my $b = notes({ record => $burial, paragraph => 0 })) {
					$b =~ tr/\r//;
					$bio .= " ($b)";
				}
				$end_of_sentence = 0;
			}
			$bio .= "[$_]" foreach(sort @burialcitations);
		} elsif((!$aod) && ($placeofdeath || $dateofdeath)) {
			# TODO - extract marriage banns information
			# if($person->marriage_bann()) {
				# die 'foo';
			# }
			if($placeofdeath && (scalar(@spouses) <= 1) && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
				if($end_of_sentence) {
					$bio .= ' That';
				} else {
					$bio .= ', which';
				}
				$bio .= ' is also where ' . lcfirst($pronoun);
			} elsif($aob && scalar(@spouses) && ($numberofchildren == 0)) {
				if($end_of_sentence) {
					$bio .= " $pronoun";
				} else {
					$bio .= ' and';
				}
			} else {
				$bio .= '.' if(!$end_of_sentence);
				if($opts{'B'}) {
					if($bio) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = '';
					}
				} else {
					$bio .= "\n\t";
				}
				$bio .= $pronoun;
			}
			$bio .= ' died';
			if($dateofdeath) {
				if($dateofbirth && ($dateofdeath eq $dateofbirth)) {
					$bio .= ' on the same day';
				} elsif($placeofdeath && $placeofmarriage && ($placeofdeath eq $placeofmarriage) && !$printed_residence) {
					$bio .= ' ' . year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				} elsif($placeofbirth && $placeofdeath && ($placeofdeath eq $placeofbirth) && (scalar(@spouses) <= 1) && ($placeofdeath =~ /^(.+?),.*/) && !$printed_residence) {
					$bio .= " in $1 " .
						year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
				} else {
					$bio .= ' ' . year({ person => $person, date => $dateofdeath, must_postdate => $birth_dt });
					if($placeofdeath && ((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage) || $printed_residence)) {
						my $place = place({ person => $person, record => $death, places_printed => \%places_printed });
						if(!defined($place)) {
							$place = place({ person => $person, place => $placeofdeath, places_printed => \%places_printed });
						}
						if(defined($place)) {
							$bio .= $place;
						} else {
							complain({
								person => $person,
								warning => "Place of death ($placeofdeath) can't be parsed"
							});
						}
					}
				}
			} elsif((!$placeofmarriage) || ($placeofdeath ne $placeofmarriage)) {
				$bio .= place({ person => $person, place => $placeofdeath });
			}
			$bio .= "[$_]" foreach(List::Util::uniq(sort @deathcitations));
			# Print notes about the death, if any
			if(defined($death) && (my $d = notes({ person => $person, record => $death, paragraph => 0 }))) {
				$d =~ tr/\r//;
				$d =~ s/\.$//;
				$bio .= " ($d)";
			}
			$end_of_sentence = 0;
		}

		$bio .= '.' if(!$end_of_sentence);

		# if($death && (my $notes = notes({ person => $person, record => $death, paragraph => 1 }))) {
			# print "\n$notes";
		# }

		if(my $notes = notes({ person => $person, record => $person, paragraph => 1 })) {
			# print "\t", join("\n\t", @notes), "\n";
			if($opts{'B'}) {
				if($bio) {
					if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
						$text->textend();

						$pdfpage = PDFPage->new();

						$text = $pdfpage->text();
						$text->font($params{'font'}, 12);
						die 'Print failure' if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage));
					}
					$bio = '';
				}

			} else {
				$bio .= "\n";
			}
			$bio .= $notes;
		}

		if($opts{'C'}) {
			foreach my $child(@children) {
				if(my $dob = get_value({ person => $child, value => 'birth date' })) {
					unless($opts{'B'}) {
						$bio .= "\n\t";
					}
					$bio .= $child->given_names() .
						' was born ' .
						year({ person => $child, date => $dob });
					if($opts{'w'} && ($birth_dt || $death_dt) &&
					   ($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/) &&
					   ($dob !~ /[a-z]$/i)) {
						my $d;
						eval {
							$d = $date_parser->parse(date => $dob);
						};
						if($d) {
							$d = @{$d}[0];
						}
						if($d) {
							$d = $dfn->parse_datetime($d->{'canonical'});
							if($birth_dt && ($d <= $birth_dt)) {
								complain({ person => $child, warning => 'born before parent was born' });
							}
							if(($sex eq 'F') && $death_dt && ($d > $death_dt)) {
								complain({ person => $child, warning => 'born after mother died' });
							} elsif(($sex eq 'M') && $death_dt && ($d > ($death_dt + $tenmonths))) {
								# Allow the child to be
								# born up to 10 months
								# after the death of the
								# father
								complain({ person => $child, warning => 'born more than 10 months after father died' });
							}
						}
					}
					$bio .= '.';
				} elsif(get_value({ person => $child, value => 'baptism date' })) {
					$bio .= "\t" . $child->given_names() .
						' was born c. ' .
						get_value({ person => $child, value => 'baptism date' }) .
						'.';
				}
			}

			$bio .= "\n" if(scalar(@children));
		}

		if($opts{'c'}) {
			my $ufinder = URI::Find::Schemeless->new(sub {
				my($uri, $orig_uri) = @_;

				if($opts{'w'}) {
					my $u = URI->new($orig_uri);
					if($u && (ref($u) ne 'URI::_generic') && !head($orig_uri)) {
						if($opts{'f'}) {
							die $person->as_string, ": $orig_uri: not found";
						}
						red_warning({ person => $person, warning => "$orig_uri: not found" });
					}
				}
				return $orig_uri;
			});

			my %census_years;
			my $burialrecord;
			foreach my $citation(1..$citationcount) {
				if(!$citations{$citation}) {
					if($opts{'f'}) {
						die $person->as_string(), "[$citation]: empty citation";
					}
					if($opts{'w'}) {
						red_warning({
							person => $person,
							warning => "[$citation]: empty citation"
						});
					}
					next;
				}
				my $title = $citations{$citation}->title();
				if(!defined($title)) {
					if($opts{'f'}) {
						die $person->as_string, "[$citation]: no citation title";
					}
					red_warning({
						person => $person,
						warning => "[$citation]: no citation title"
					});
					next;
				}
				if($opts{'B'}) {
					if($bio) {
						if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							pdfprint(string => $bio, text => $text, pdfpage => $pdfpage);
						}
						$bio = '';
					}
				} else {
					$bio =~ s/\s+$//;
					$bio .= "\n\t";
				}
				$bio .= "[$citation]: $title";
				# if(defined(my $publication = $citations{$citation}->publication())) {
					# print " $publication";
					# if(defined(my $continuation = $citations{$citation}->cont())) {
						# print $continuation;
					# }
				# }
				if(defined(my $page = $citations{$citation}->page())) {
					$bio .= " $page";
				}

				my @notes = $citations{$citation}->note();
				foreach my $note(@notes) {
					if(ref($note) eq 'Gedcom::Record') {
						$note = $note->note();
					}

					if($note && ($note !~ /^This information comes from/)) {
						if($opts{'w'}) {
							$ufinder->find(\$note);
						}
						$bio .= " ($note)";
					}
				}
				if($citationnotes{$citation}) {
					$citationnotes{$citation} =~ s/\.$//;
					$bio .= " ($citationnotes{$citation})";
				}

				if(($title =~ /census/i) && ($title =~ /(\d{3,4})/)) {
					$census_years{$1} = $title;
				}
				if(($title =~ /find a grave/i) ||
				   ($title =~ /billiongraves/i)) {
					$burialrecord = 1;
				}
			}
			$bio .= "\n" if($citationcount);

			if($opts{'w'}) {
				my %unused_censuses = %census_years;
				foreach my $residence(@residences) {
					if(my $rdate = $residence->date()) {
						if($rdate =~ /(\d{3,4})$/) {
							$rdate = $1;
							delete $unused_censuses{$1};
						}
					}
				}
				foreach my $year(sort keys %unused_censuses) {
					complain({
						person => $person,
						warning => "The census for year $year has been citied, but its information has not been used as a residence"
					});
				}
				foreach my $event(@events) {
					if(ref($event) eq 'Gedcom::Record') {
						my $type = $event->type();
						my $year;
						if($type =~ /^Census U[KS] (\d{4})$/) {
							$year = $1;
							if(!$event->date()) {
								complain({ person => $person, warning => "Census for $year missing a date" });
							}
						} elsif($type eq 'Register UK 1939') {
							if(!$event->date()) {
								complain({ person => $person, warning => '1939 UK register is missing the date 29 Sep 1939' });
							}
							$year = 1939;
						} else {
							next;
						}
						$census_years{$year} = $type;
						if(defined($yod) && ($year > $yod)) {
							complain({ person => $person, warning => "Census for $year after year of death ($yod)" });
						} elsif(defined($yob) && ($year < $yob)) {
							complain({ person => $person, warning => "Census for $year before year of birth ($yob)" });
						}
					}
				}
				foreach my $year(sort { $a <=> $b } keys(%census_years)) {
					if($census_years{$year + 20} && !$census_years{$year + 10}) {
						complain({
							person => $person,
							warning => 'Census information missing between ' . $census_years{$year} . ' and ' . $census_years{$year + 20}
						});
					}
				}
				if($dateofdeath && !defined($placeofdeath)) {
					complain({ person => $person, warning => 'Date of death is known, but not place' });
				} elsif($placeofbirth && $dateofdeath && (!$census_years{1939}) &&
				   (datecmp($dateofdeath, '1939') >= 0) && ($placeofbirth =~ /England$/) && ($placeofdeath =~ /England$/) &&
				   ((!$dateofbirth) || (datecmp($dateofbirth, '1939') <= 0))) {
				   	my $has1939 = 0;
					foreach my $residence(@residences) {
						if($residence->date() && ($residence->date() =~ /1939$/)) {
							$has1939 = 1;
							last;
						}
					}
					if(!$has1939) {
						complain({
							person => $person,
							warning => '1939 UK register information missing'
						});
					}
				}
				my $surname = $lastname;
				if(defined($sex) && ($sex eq 'F')) {
					if(my $husband = $person->husband()) {
						$surname = $husband->surname();
					}
				}
				if($yod && $firstname && $surname && !$burialrecord) {
					my %opts = (
						date_of_death => $yod,
						firstname => $firstname,
						lastname => $surname,
						ua => $browser,
					);
					if($placeofburial) {
						if($placeofburial =~ /.+,\s+(\w+)/) {
							$opts{'country'} = $1;
						}
					} elsif($placeofdeath) {
						if($placeofdeath =~ /.+,\s+(\w+)/) {
							$opts{'country'} = $1;
						}
					}
					if($opts{'country'} && ($opts{'country'} eq 'USA')) {
						$opts{'country'} = 'United States of America';
					}
					# foreach my $b(WWW::Scrape::FindaGrave->new(\%opts)) {
					if(defined($grave_modules)) {
						if(ref($grave_modules)) {
							foreach my $m(@{$grave_modules}) {
								$b = $m->new(\%opts);
								while(my $url = $b->get_next_entry()) {
									complain({
										person => $person,
										warning => "possible burial link $url"
									});
								}
							}
						} else {
							$b = $grave_modules->new(\%opts);
							while(my $url = $b->get_next_entry()) {
								complain({
									person => $person,
									warning => "possible burial link $url"
								});
							}
						}
					}
				}
			}
		}
		if($opts{'B'}) {
			if($bio) {
				$bio =~ s/\.\././g;
				if(length($bio) > 4000) {
					# It's not going to fit on one page
					# Split into paragraphs
					my @paras = split(/\n/, $bio);
					foreach my $p(@paras) {
						next if(length($p) == 0);
						if(length($p) > 4000) {
							# Very long paragraph
							my @lines = split(/\n/, wrap('', '', ($p)));
							foreach my $l(@lines) {
								if(!pdfprint(string => $l, text => $text, pdfpage => $pdfpage, noindent => 1)) {
									$text->textend();

									$pdfpage = PDFPage->new();

									$text = $pdfpage->text();
									$text->font($params{'font'}, 12);
									die "Print failure: $l" if(!pdfprint(string => $l, text => $text, pdfpage => $pdfpage, noindent => 1));
								}
							}
						} elsif(!pdfprint(string => $p, text => $text, pdfpage => $pdfpage)) {
							$text->textend();

							$pdfpage = PDFPage->new();

							$text = $pdfpage->text();
							$text->font($params{'font'}, 12);
							die "Print failure: $p" if(!pdfprint(string => $p, text => $text, pdfpage => $pdfpage));
						}
					}
				} elsif(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage)) {
					$text->textend();

					$pdfpage = PDFPage->new();

					$text = $pdfpage->text();
					$text->font($params{'font'}, 12);
					die 'Print failure' if(!pdfprint(string => $bio, text => $text, pdfpage => $pdfpage));
				}
				$bio = undef;
			}
		} else {
			if($bio eq "\t.") {
				complain({ person => $person, warning => "couldn't extract a biography" });
			}
			print "$bio\n", '-' x 80, "\n";
		}
	} else {
		my ($dob, $dod);
		eval {
			$dob = $person->get_value('birth date');
			$dod = $person->get_value('death date');
		};
		if($@) {
			warn "Can't parse record for $firstname $lastname";
			return;
		}

		if(defined($dob) && (!$onlydeaths) && !$onlybirthdays) {
			my $d;
			if(($dob !~ /^\d{3,4}$/) && ($dob =~ /^\d/)) {
				eval {
					$d = $date_parser->parse(date => $dob);
				};
			}
			if($d) {
				$d = @{$d}[0];
				$birth_dt = $dfn->parse_datetime($d->{'canonical'});
				print "\tBorn: ", $birth_dt->strftime('%x');
			} else {
				if($@) {
					if($opts{'f'}) {
						die $@;
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => $@ });
					}
				}
				print "\tBorn: $dob";
			}
			print "\n";
		}
		if(defined($dod) && (!$onlydeaths) && !$onlybirthdays) {
			my $d;
			if(($dod !~ /^\d{3,4}$/) && ($dod =~ /^\d/)) {
				eval {
					$d = $date_parser->parse(date => $dod);
				};
			}
			if($d) {
				$d = @{$d}[0];
				$death_dt = $dfn->parse_datetime($d->{'canonical'});
				print "\tDied: ", $death_dt->strftime('%x');
			} else {
				if($@) {
					if($opts{'f'}) {
						die $@;
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => $@ });
					}
				}
				print "\tDied: $dod\n";
			}
			print "\n";
		}
	}
	$printed{$person->{'xref'}} = 1;

	if($opts{'B'}) {
		my @images;
		my %files;
		foreach my $o($person->obje()) {
			my $obje;
			if(ref($o) eq 'Gedcom::Record') {
				$obje = $o;	# e.g. Ancestry
			} else {
				$obje = $ged->resolve_xref($o);	# e.g. FMP
			}
			next if(!defined($obje));
			if(my $file = $obje->file()) {
				if(ref($file) eq 'Gedcom::Record') {
					# warn $file->tag(), "\n" if($file->tag());
					$file = $file->{'file'};
					next if($file eq '*');
				}
				if($files{$file}) {
					print "$file is already printed\n" if($opts{'v'});
					next;
				}
				$files{$file} = 1;
				my $title = $obje->title() || $obje->tag_record('TITL', 1);
				my $form = $obje->form();
				if((!$form) && $obje->items()) {
					# Family Tree Maker does this
					my @items = $obje->items();
					$file = $items[0]->{'value'};
					# TODO: Find the title
				}
				$file =~ s/\{0\}//g;
				$file =~ s/\r//g;
				my $image;
				my $filename;
				my $orig_image;
				my $orig_filename;
				my $gd;
				if($file =~ /^http:\/\/(\w+)\.findmypast\.(co[\w\.]+)\/(.+)/) {
					$file = "https://$1.findmypast.$2/$3";
				}
				if(($file =~ /^https?:\/\//) && ($file !~ /\.jpe?g$/) && ($file !~ /ancestry.com.*image.*guid=/)) {
					$file =~ s/%2f/\//gi;

					my $resp = $browser->get($file);
					if($resp->is_success() && ($resp->content_type() eq 'image/jpeg')) {
						$title = $file if(!defined($title));
						my $tmp = File::Temp->new(UNLINK => 0);
						$filename = $tmp->filename();
						open(my $fh, '>', $tmp->filename());
						print $fh $resp->decoded_content();
						close $fh;
						$orig_filename = $filename;
						my $resize = Image::Resize->new($filename);
						my $width = $resize->width();
						my $height = $resize->height();
						if($height > 250) {
							my $newwidth = $width * (250 / $height);
							my $newheight;
							if($newwidth > 550) {
								$newheight = $height * (550 / $width);
								$gd = $resize->resize(550, $newheight);
							} else {
								$gd = $resize->resize($newwidth, 250);
								$newheight = 205;
							}
						} elsif($width > 550) {
							my $newheight = $height * (550 / $width);
							$gd = $resize->resize(550, $newheight);
						}
						if($gd) {
							$image = $pdf->image_gd($gd, -lossless => 1);
						} else {
							$image = $pdf->image_jpeg($filename);
						}
						$orig_image = $pdf->image_jpeg($orig_filename);
					} else {
						if(!$resp->is_success()) {
							complain({ person => $person, warning => "download $file failed " . $resp->status_line() });
						}
						$title = undef;
					}
				} elsif(($file =~ /^([A-Z]:[\/\\].+\.jpe?g+)/) || ($file =~ /^(\/.+\.jpe?g)/)) {
					$form = 'JPG';
				}
				if((!defined($image)) && $form && (lc($form) eq 'jpg')) {
					if($file =~ /ancestry.com.+guid=.+&tid=/) {
						# Ancestry's Gedcoms are broken, perhaps pointing to an old
						# location that they forgot to fix
						if($file =~ /guid=([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/) {
							# FIXME: Ancestry pictures attached from another
							# tree aren't downloaded.  This URL will generate a
							# 404
							$file = "https://mediasvc.ancestry.com/v2/image/namespaces/1093/media/$1.jpg?client=Trees";
						} else {
							complain({ person => $person, warning => "BUG: update ACOM mapping for $file" });
							unlink $filename if(defined($filename));
							unlink $orig_filename if(defined($orig_filename));
							next;
						}
					}
					my $rc;
					my $tmp = File::Temp->new(UNLINK => 0);
					$filename = $tmp->filename();
					$orig_filename = $filename;
					if(is_success($rc = getstore($file, $filename))) {
						my $resize = Image::Resize->new($filename);
						my $width = $resize->width();
						my $height = $resize->height();
						if($height > 250) {
							my $newwidth = $width * (250 / $height);
							my $newheight;
							if($newwidth > 550) {
								$newheight = $height * (550 / $width);
								$gd = $resize->resize(550, $newheight);
							} else {
								$gd = $resize->resize($newwidth, 250);
								$newheight = 250;
							}
						} elsif($width > 550) {
							my $newheight = $height * (550 / $width);
							$gd = $resize->resize(550, $newheight);
						}
						if($gd) {
							# $orig_image = $pdf->image_jpeg($orig_filename);
							# $tmp = File::Temp->new(UNLINK => 0);
							# $filename = $tmp->filename();
							# open(my $fh, '>', $filename);
							# print $fh $gd->jpeg();
							# close $fh;
							$image = $pdf->image_gd($gd, -lossless => 1);
						}
						$image = $pdf->image_jpeg($filename);
						$title = $file if(!defined($title));
						# $image->height(32);
						# $image->width(32);
					} else {
						red_warning({ person => $person, warning => "download $file failed to $filename: $rc" });
						$title = undef;
					}
				}
				if($title) {
					push @images, { image => $image, orig_image => $orig_image, title => $title, orig_filename => $orig_filename };
				}
				push @tmpfiles, $filename if(defined($filename));
				push @tmpfiles, $orig_filename if(defined($orig_filename) && ($orig_filename ne $filename));
			}
		}
		if(scalar(@images)) {
			$text->textend();
		}
		while(my $i = shift @images) {
			my $title = $i->{'title'};

			my $newpage;
			my $trigger_page_throw;
			if(my $image = $i->{'image'}) {
				if($opts{'v'}) {
					print "$title: height/width: ", $image->height(), '/', $image->width(), "\n";
				}

				if(($image->height() >= ($pdfpage->y() - 80)) ||
				   ($pdfpage->linesleft() <= 15)) {
					print "New page to fit image on it\n" if($opts{'v'});
					$pdfpage = PDFPage->new();
					$newpage = 1;
				}
				my $y = $pdfpage->newline() - $image->height();

				if(my $peek = $images[0]) {
					if(my $pimage = $peek->{'image'}) {
						if(($image->width() < 250) && ($pimage->width() < 250) &&
						   ($pimage->height() <= $y) && ($pimage->height() <= $image->height())) {
							# Print two images side by side
							$peek = shift @images;

							my $x = 150 - ($image->width() / 2);
							$pdfpage->page()->gfx()->image($image, $x, $y);
							$x = 450 - ($pimage->width() / 2);
							$pdfpage->page()->gfx()->image($pimage, $x, $y);
							$pdfpage->y($y);

							$text = $pdfpage->text();
							# This is needed because of the text end above
							$text->textstart() if(!$newpage);
							$text->font($pdf->corefont('Times-Italic'), 12);
							$x = 150 - (length($title) / 2);
							if(!pdfprint(string => $title, text => $text, pdfpage => $pdfpage, x => $x, centre => 1)) {
								die "Didn't make enough room for $title; y = ", $pdfpage->y();
							}
							my $ptitle = $peek->{'title'};
							$pdfpage->y($y);	# Put the two captions on the same line
							$x = 450 - (length($ptitle) / 2);
							if(!pdfprint(string => $ptitle, text => $text, pdfpage => $pdfpage, x => $x, centre => 1)) {
								die "Didn't make enough room for $ptitle ; y = ", $pdfpage->y();
							}
							# $text->textend();
							next;
						}
					}
				}

				my $orig_image = $i->{'orig_image'};

				next unless($image || $orig_image);

				if($orig_image && ($pdfpage->y() > ($orig_image->height() + 80)) && ($orig_image->width() < 550)) {
					# No need to shrink the image
					$y = $pdfpage->y() - $orig_image->height();
					my $x = 300 - ($orig_image->width() / 2);
					$pdfpage->page()->gfx()->image($orig_image, $x, $y);
					$pdfpage->y($y);
				} elsif($orig_image && $newpage && ($orig_image->width() < 550)) {
					# Shrink the image to take the entire page height and appropriate width
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					if($height >= 650) {
						my $newwidth = ($width * 650) / $height;
						my $gd = GD::Image->new($i->{'orig_filename'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize($newwidth, 650);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$width = $newwidth;
						$height = 650;
					} else {
						$image = $orig_image;
					}
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
				} elsif($orig_image && $newpage && ($orig_image->height() < 650)) {
					# Shrink the image to take the entire page width and appropriate height
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					if($width >= 500) {
						my $newheight = ($height * 500) / $width;
						my $gd = GD::Image->new($i->{'orig_filename'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize(500, $newheight);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$width = 500;
						$height = $newheight;
					} else {
						$image = $orig_image;
					}
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
				} elsif($orig_image && $newpage) {
					if($opts{'v'}) {
						print "$title height and width are too big. height/width: ", $orig_image->height(), '/', $orig_image->width(), "\n";
					}
					# Handle when both height and width are too big
					my $width = $orig_image->width();
					my $height = $orig_image->height();
					my $newwidth = ($width * 650) / $height;
					my $newheight = 650;
					if($newwidth > 500) {
						$newheight = ($height * 500) / $width;
						$newwidth = 500;
					}
					my $gd = GD::Image->new($i->{'orig_filename'});
					my $resize = Image::Resize->new($gd);
					$gd = $resize->resize($newwidth, $newheight);
					$image = $pdf->image_gd($gd, -lossless => 1);
					$height = $newheight;
					$width = $newwidth;
					my $x = 300 - ($width / 2);
					$pdfpage->page()->gfx()->image($image, $x, 740 - $height);
					$pdfpage->y(740 - $height);
					$trigger_page_throw = 1;
				} else {
					# Shrink the image to fit on the page
					if($image->height() > 650) {
						my $width = $image->width();
						my $height = $image->height();
						my $newwidth = ($width * 650) / $height;
						my $newheight = 650;
						if($newwidth > 500) {
							$newheight = ($height * 500) / $width;
							$newwidth = 500;
						}
						my $gd = GD::Image->new($i->{'orig_filename'});
						my $resize = Image::Resize->new($gd);
						$gd = $resize->resize($newwidth, $newheight);
						$image = $pdf->image_gd($gd, -lossless => 1);
						$height = $newheight;
						$width = $newwidth;
						$y = $pdfpage->newline() - $newheight;
					}
					my $x = 300 - ($image->width() / 2);
					$pdfpage->page()->gfx()->image($image, $x, $y);
					if($image->height() >= ($y - 80)) {
						print "It took the entire page\n" if($opts{'v'});
					}
					$pdfpage->y($y);
				}
			}

			if($title) {
				$text = $pdfpage->text();
				# This is needed because of the text end above
				$text->textstart() if(!$newpage);
				$text->font($pdf->corefont('Times-Italic'), 12);
				if(length($title) > 200) {
					complain({ person => $person, warning => "Truncating long picture title $title" });
					$title = substr $title, 0, 200;
				}
				my $x = 300 - (length($title) / 2);
				if(!pdfprint(string => $title, pdfpage => $pdfpage, x => $x, centre => 1)) {
					die "Didn't make enough room for '$title'; y = " . $pdfpage->y();
				}
				# $text->textend();
			}
			if($trigger_page_throw) {
				$pdfpage = PDFPage->new();
			}
		}
	}
}

sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $name;

	if($args{'use_aka'}) {
		my $n2 = $self->tag_record('NAME', 2);
		if(defined($n2) && (ref($n2) eq 'Gedcom::Record') && defined($n2->type()) && ($n2->type() eq 'AlsoKnownAs') && ($n2->value() ne $self->name())) {
			$name = $n2->value();
		} else {
			return;
		}
	} else {
		$name = $self->name();
	}

	$name =~ s/\///g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'};
	my $middle_name = $name_components{'middle_name'};
	my $surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	if($name_components{'non_matching'}) {
		if($name =~ /(\w{2,})\s(\w{2,})\s(\w+)\s(\w{2,})/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			my $rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
			$surname .= $rest;

			# Remove the middle name, since it's come in from the non_matching
			$middle_name = undef;
			delete $args{'middle_names'};
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $has_maiden_name;
	if($args{'nee'}) {
		my $sex = get_value({ person => $self, value => 'sex' });
		if(defined($sex) && ($sex eq 'F')) {
			if(my $husband = $self->husband()) {
				$surname = $husband->surname();
				$has_maiden_name = 1;
			} elsif(my $spouse = $self->spouse()) {
				complain({ person => $self, warning => 'married, but no husband relationship' });
				$surname = $spouse->surname();
				$has_maiden_name = 1;
			}
		}
	}

	my $rc;

	if($args{'title'} && $name_components{'title_1'}) {
		$rc = $name_components{'title_1'};
		if($rc) {
			$rc .= ' ';
		}
	}

	if($first_name) {
		$rc .= $first_name;
	} elsif($self->given_names()) {
		$rc .= $self->given_names();
	} elsif($args{'print_unknown'}) {
		$rc .= ' ?';
	}

	if($args{'middle_names'}) {
		if($middle_name) {
			$rc .= " $middle_name";
		} elsif($name =~ /\s([A-Z])\s.+/) {
			# Just an initial has been given
			$rc .= " $1";
		}
	}

	if($surname) {
		if($rc) {
			$rc .= ' ';
		}
		$rc .= normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} elsif($args{'print_unknown'}) {
		$rc .= ' ?';
	}

	if($has_maiden_name && $self->surname()) {
		$rc .= ' (nee ' . normalize_name($self->surname()) . ')';
	}

	if(!defined($rc)) {
		if($opts{'f'}) {
			die "Can't determine name of this person";
		}
		if($opts{'w'}) {
			red_warning({ warning => "Can't determine name of this person" });
			$args{'include_years'} = 1;
			$rc = 'Unknown person ';
		}
	}

	if($args{'include_years'}) {
		my $dob = get_value({ person => $self, value => 'birth date' });

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			if($dob =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yob = "c$1";	# Get the "1951" from "Feb 1951"
				}
				$yob = "c$year";
			} else {
				$yob = $1;
			}
		} else {
			$dob = get_value({ person => $self, value => 'baptism date' });
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = get_value({ person => $self, value => 'death date' });

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			if($dod =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				my $year = $2;
				if($year =~ /^[A-Z]{3}\s(.+)/i) {
					$yod = "c$1";	# Get the "1951" from "Feb 1951"
				} else {
					$yod = "c$year";
				}
			} else {
				$yod = $1;
			}
		} else {
			$dod = get_value({ person => $self, value => 'burial date' });
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ' if($yob || $yod);

		if($yob) {
			$rc .= "$yob ";
		}

		$rc .= '-' if($yob || $yod);

		if($yod) {
			return "$rc $yod";
		}
	}

	if((!defined($rc)) && $opts{'w'}) {
		complain({ warning => "Can't determine the name for record " . $self->{'xref'} });
		return '';
	}

	$rc =~ tr/"/'/;	# fix issues with Graphviz and others - compatibility with ged2site

	return $rc;
}

sub Gedcom::Individual::as_sort_key
{
	my $self = shift;
	my $surname = $self->surname();
	my $given_names = $self->given_names();

	if($surname && length($surname)) {
		if($given_names) {
			if($surname =~ /\s(.+?)$/) {
				$surname = $1;
			}
			return normalize_name("$surname, $given_names");
		} else {
			return normalize_name($surname) . ', ZZZZZ';
		}
	} elsif($given_names) {
		return 'ZZZZZ, ' . normalize_name($given_names);
	}

	my $name = $self->name();

	$name =~ s/\///g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'};
	my $middle_name = $name_components{'middle_name'};
	$surname = $name_components{'surname_1'};
	if($name_components{'surname_2'}) {
		$surname .= ' ' . $name_components{'surname_2'};
	}
	my $rest;
	if($name_components{'non_matching'}) {
		if($name =~ /(\w+)\s(\w+)\s(\w+)\s(\w+)$/) {
			# Name parser doesn't parse names like this very well
			$first_name = $1;
			$middle_name = "$2 $3";
			$surname = $4;
		} else {
			if($surname) {
				$surname .= ' ';
			}
			$rest = $name_components{'non_matching'};
			if($rest =~ /(.+) $/) {
				$rest = $1;
			}
		}
	} elsif(!defined($surname)) {
		$surname = $self->surname();
	}

	my $rc;

	if($surname) {
		$rc = normalize_name($surname);
		if(my $suffix = $name_components{'suffix'}) {
			$rc .= " $suffix";
		}
	} else {
		$rc = 'ZZZZZZ';
	}

	if($first_name) {
		$rc .= ", $first_name";
	} elsif($given_names) {
		$rc .= ", $given_names";
	}

	if($middle_name) {
		$rc .= " $middle_name";
	} elsif($name =~ /\s([A-Z])\s.+/) {
		# Just an initial has been given
		$rc .= " $1";
	}

	if($rest) {
		$rc .= $rest;
	}

	if((!defined($rc)) && $opts{'w'}) {
		if($opts{'f'}) {
			die "\nCan't determine the name for record " . $self->{'xref'};
		}
		red_warning({ "Can't determine the name for record " . $self->{'xref'} });
		return '';
	}

	return $rc;
}

sub normalize_name
{
	# my $name = shift;

	# my $rc;
	# foreach my $word(split(/-| |'/, lc($name))) {
		# $rc .= '-' if($rc && ($name =~ /-/));
		# $rc .= "'" if($rc && ($name =~ /'/));
		# $rc .= ' ' if($rc && ($name =~ / /));
		# $rc .= ucfirst($word);
	# }

	# return $rc;

	return Lingua::EN::NameCase::nc(shift);
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	my $sex = get_value({ person => $self, value => 'sex' });

	if(defined($sex)) {
		if($sex eq 'F') {
			return 'She';
		}
		if($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

sub Gedcom::Individual::possessive
{
	my $self = shift;

	my $rc = {
		'He' => 'His',
		'She' => 'Her',
		'They' => 'Their',
	};

	return $rc->{$self->pronoun()};
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship {
	my $self = shift;
	my $other = shift;

	if($self->mother() && $other->mother() && $self->father() && $other->father()) {
		my $sex = get_value({ person => $other, value => 'sex' });
		if(($self->mother() eq $other->mother()) && ($self->father() eq $other->father())) {
			return ($sex eq 'M') ? 'brother' : 'sister';
		}
		if(($self->mother() eq $other->mother()) || ($self->father() eq $other->father())) {
			return ($sex eq 'M') ? 'half-brother' : 'half-sister';
		}
	}

	return $self->relationship_down($other) || $self->relationship_up($other);
}

sub Gedcom::Individual::relationship_up
{
	my $self = shift;
	my $other = shift;

	unless(@myancestors) {
		@myancestors = $self->ancestors();
	}
	return unless @myancestors;

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		complain({ person => $other, warning => 'unknown sex' });
		return;
	}

	foreach my $person1(@myancestors) {
		die if($person1 eq $self);
		if($person1 eq $other) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title = ($sex eq 'M') ? 'father' : 'mother';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} elsif($steps == 3) {
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	foreach my $person1(@myancestors) {
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# TODO - apparently fixed in Github, awaiting new version on CPAN
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }

			if($person1 eq $person2) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				# die $steps1 if($steps1 > 23);
				return if($steps1 > 23);
				my $steps2 = stepsabove($other, $person2, 0);
				# die $steps2 if($steps2 > 23);
				return if($steps2 > 23);

				# TODO: It would be nice to do this as an algorithm
				my %male_relationships = (
					1 << 24 | 1 => 'brother',
					1 << 24 | 2 => 'nephew',
					1 << 24 | 3 => 'great-nephew',
					2 << 24 | 1 => 'uncle',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-uncle',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-uncle',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					5 << 24 | 1 => 'third times great-uncle',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					6 << 24 | 1 => 'four times great-uncle',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-uncle',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-uncle',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-uncle',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-uncle',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-uncle',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-uncle',
					14 << 24 | 1 => 'twelve times great-uncle',
					15 << 24 | 1 => 'thirteen times great-uncle',
					16 << 24 | 1 => 'fourteen times great-uncle',
					17 << 24 | 1 => 'fifteen times great-uncle',
					18 << 24 | 1 => 'sixteen times great-uncle',
				);
				my %female_relationships = (
					1 << 24 | 1 => 'sister',
					1 << 24 | 2 => 'niece',
					1 << 24 | 3 => 'great-niece',
					2 << 24 | 1 => 'aunt',
					2 << 24 | 2 => 'cousin',
					2 << 24 | 3 => 'first cousin once-removed',
					2 << 24 | 4 => 'first cousin twice-removed',
					2 << 24 | 5 => 'first cousin three-times-removed',
					3 << 24 | 1 => 'great-aunt',
					3 << 24 | 2 => 'first cousin once-removed',
					3 << 24 | 3 => 'second cousin',
					3 << 24 | 4 => 'second cousin once-removed',
					3 << 24 | 5 => 'second cousin twice-removed',
					3 << 24 | 6 => 'second cousin three-times-removed',
					4 << 24 | 1 => 'great-great-aunt',
					4 << 24 | 2 => 'first cousin twice-removed',
					4 << 24 | 3 => 'second cousin once-removed',
					4 << 24 | 4 => 'third cousin',
					4 << 24 | 5 => 'third cousin once-removed',
					4 << 24 | 6 => 'third cousin twice-removed',
					5 << 24 | 1 => 'third times great-aunt',
					5 << 24 | 2 => 'first cousin three-times-removed',
					5 << 24 | 3 => 'second cousin twice-removed',
					5 << 24 | 4 => 'third cousin once-removed',
					5 << 24 | 5 => 'fourth cousin',
					5 << 24 | 6 => 'fourth cousin once-removed',
					6 << 24 | 1 => 'four times great-aunt',
					6 << 24 | 2 => 'first cousin four-times-removed',
					6 << 24 | 3 => 'second cousin three-times-removed',
					6 << 24 | 4 => 'third cousin twice-removed',
					6 << 24 | 5 => 'fourth cousin once-removed',
					6 << 24 | 6 => 'fifth cousin',
					6 << 24 | 7 => 'fifth cousin once-removed',
					6 << 24 | 8 => 'fifth cousin twice-removed',
					7 << 24 | 1 => 'fifth times great-uncle',
					7 << 24 | 2 => 'first cousin five-times-removed',
					7 << 24 | 3 => 'second cousin four-times-removed',
					7 << 24 | 4 => 'third cousin three-times-removed',
					7 << 24 | 5 => 'fourth cousin twice-removed',
					7 << 24 | 6 => 'fifth cousin once-removed',
					7 << 24 | 7 => 'sixth cousin',
					7 << 24 | 8 => 'sixth cousin once-removed',
					8 << 24 | 1 => 'six times great-aunt',
					8 << 24 | 2 => 'first cousin six-times-removed',
					8 << 24 | 3 => 'second cousin five-times-removed',
					8 << 24 | 4 => 'third cousin four-times-removed',
					9 << 24 | 1 => 'seven times great-aunt',
					9 << 24 | 2 => 'first cousin seven-times-removed',
					9 << 24 | 3 => 'second cousin six-times-removed',
					9 << 24 | 4 => 'third cousin five-times-removed',
					10 << 24 | 1 => 'eight times great-aunt',
					10 << 24 | 2 => 'first cousin eight-times-removed',
					10 << 24 | 3 => 'second cousin seven-times-removed',
					10 << 24 | 4 => 'third cousin six-times-removed',
					11 << 24 | 1 => 'nine times great-aunt',
					11 << 24 | 2 => 'first cousin nine-times-removed',
					11 << 24 | 3 => 'second cousin eight-times-removed',
					11 << 24 | 4 => 'third cousin seven-times-removed',
					11 << 24 | 5 => 'fourth cousin six-times-removed',
					12 << 24 | 1 => 'ten times great-aunt',
					12 << 24 | 2 => 'first cousin ten-times-removed',
					12 << 24 | 3 => 'second cousin nine-times-removed',
					12 << 24 | 4 => 'third cousin eight-times-removed',
					12 << 24 | 5 => 'fourth cousin seven-times-removed',
					13 << 24 | 1 => 'eleven times great-aunt',
					14 << 24 | 1 => 'twelve times great-aunt',
					15 << 24 | 1 => 'thirteen times great-aunt',
					16 << 24 | 1 => 'fourteen times great-aunt',
					17 << 24 | 1 => 'fifteen times great-aunt',
					18 << 24 | 1 => 'sixteen times great-aunt',
				);

				my $rc = ($sex eq 'M') ?
					$male_relationships{($steps1 << 24) | $steps2} :
					$female_relationships{($steps1 << 24) | $steps2};
				if(defined($rc) && ($rc =~ /cousin/)) {
					my $myfather = $self->father();
					my $mymother = $self->mother();
					if($myfather && (stepsabove($myfather, $person2, 0) > 0)) {
						$rc .= ' on your father\'s side';
					} elsif($mymother && (stepsabove($mymother, $person2, 0) > 0)) {
						$rc .= ' on your mother\'s side';
					}
				}
				if(!defined($rc)) {
					# die $other->as_string(), ": $steps1, $steps2";
					complain({ person => $other, warning => "TODO: $steps1, $steps2" });
				}
				return $rc;
			}
		}
	}
}

sub Gedcom::Individual::relationship_down
{
	my $self = shift;
	my $other = shift;

	unless(@mydescendents) {
		@mydescendents = $self->descendents();
	}
	return unless @mydescendents;

	my $sex = get_value({ person => $other, value => 'sex' });
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		if($opts{'f'}) {
			die "\n", $other->as_string(), ": unknown sex\n";
		}
		if($opts{'w'}) {
			red_warning({ person => $other, warning => 'unknown sex' });
		}
		return;
	}

	foreach my $person1(@mydescendents) {
		die if($person1 eq $self);
		if($person1 eq $other) {
			# Direct desendent
			my $steps = stepsabove($other, $self, 0);
			my $title = ($sex eq 'M') ? 'son' : 'daughter';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} elsif($steps == 3) {
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if(my $spouse = $other->spouse()) {
					if(stepsabove($self, $spouse, 0)) {
						# The caller should now check
						# the spouse's relationship
						return;
					}
				}
				complain({ person => $other, warning => ": BUG - not a direct ancestor, steps = $steps" });
			}
		}
	}
}

sub stepsabove
{
	my $person = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if($person eq $target) {
		return $count;
	}

	my @father = $person->father();
	if(my $father = $father[0]) {
		my $rc = stepsabove($father, $target, $count + 1);
		return $rc if($rc != -1);
	}

	my @mother = $person->mother();
	if(my $mother = $mother[0]) {
		return stepsabove($mother, $target, $count + 1);
	}

	return -1;
}

sub year
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $string = $params{'string'} || $params{'date'};

	if(!defined($string)) {
		$string = $params{'record'};
		return unless($string);

		if(ref($string) eq 'Gedcom::Record') {
			$string = $string->date();
			return unless($string);
		}
	}

	if($string =~ /^\d{3,4}$/) {
		return "in $string";
	}
	if($string =~ /^(Abt|ca?)\.?\s*(.+)/i) {
		my $rc = $2;
		if($opts{'w'}) {
			if(my $must_postdate = $params{'must_postdate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt < $must_postdate)) {
					complain({ person => $params{'person'}, warning => "something is wrong with the date $string which should be after $must_postdate" });
				}
			}
			if(my $must_predate = $params{'must_predate'}) {
				my $dt;
				if($rc !~ /^\d/) {
					$dt = date_to_datetime("1 $rc");
				} else {
					$dt = date_to_datetime($rc);
				}
				if($dt && ($dt > $must_predate)) {
					complain({ person => $params{'person'}, warning => "something is wrong with the date $string which should be before $must_predate" });
				}
			}
		}
		if($params{'circa'}) {
			return $params{'circa'} . " $rc";
		}
		return "c. $rc";
	}
	if($string =~ /^bet (.+) and (.+)/i) {
		my $from = year({ %params, string => $1 });
		my $to = year({ %params, string => $2 });
		$from =~ s/^(in|on|c.) //;
		$to =~ s/^(in|on|c.) //;
		return "from $from to $to";
	}

	if($string =~ /(.+)\s(\d{4})\/\d{2}/) {
		my $year = $2 + 1;
		complain({ person => $params{'person'}, warning => "old-style date ($string) should be in $year" });
		$string = "$1 $year";
	}

	if(($string =~ /^\d/) && ($string !~ /[a-z]$/i)) {
		my $person = $params{'person'};
		if($string =~ /^31 Nov/) {
			if($opts{'f'}) {
				die $person->as_string(), ": $string is invalid, there are only 30 days in November";
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => "$string is invalid, there are only 30 days in November" });
			}
			return;
		}
		if(my $d = date_parser_cached(date => $string)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if(my $must_postdate = $params{'must_postdate'}) {
				complain({ person => $person, warning => "something is wrong with the date $string which should be after " . $must_postdate->strftime('%x') }) if($d < $must_postdate);
			}
			if(my $must_predate = $params{'must_predate'}) {
				complain({ person => $person, warning => "something is wrong with the date $string which should be before " . $must_predate->strftime('%x') }) if($d > $must_predate);
			}
			return 'on ' . $d->strftime('%x');
		}
		if($@) {
			# RT 107354
			chomp $@;
			if($opts{'f'}) {
				if($person) {
					die $person->as_string() . ": $@";
				}
				die $@;
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => $@ });
			}
		}
		return "on $string";
	}
	if($string =~ /^bef.? (\d{3,4})/i) {
		return "before $1";
	}
	if($string =~ /^by.? (\d{3,4})/i) {
		return "by $1";
	}
	if($string =~ /^By (\d{3,4})/i) {
		my $person = $params{'person'};
		if($opts{'f'}) {
			if($person) {
				die $person->as_string() . " says 'By' instead of 'Bef'";
			}
			die "Got 'By' instead of 'Bef'";
		}
		if($opts{'w'}) {
			if($person) {
				red_warning({ person => $person, warning => "says 'By' instead of 'Bef'" });
			} else {
				warn colored("Got 'By' instead of 'Bef'", 'red');
			}
		}
		return "before $1";
	}

	$string = ucfirst(lc($string));
	return ($string =~ /\d$/) ? "in $string" : "on $string";
}

sub place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	my $address = $params{'address'};

	if(!defined($place)) {
		$place = $params{'record'};
		return unless($place);

		if(ref($place) eq 'Gedcom::Record') {
			my $p = $place;
			$address = $place->address();
			if(ref($address) eq 'Gedcom::Record') {
				$place = getaddress($address);
				$address = undef;
			} else {
				$place = $place->place();
			}
			if(!defined($place)) {
				if(!$params{'allow_empty'}) {
					if(my $date = $p->date()) {
						complain({ person => $params{'person'}, warning => "Location for the event on $date is empty" });
					} else {
						complain({ person => $params{'person'}, warning => 'Location is empty' });
					}
				}
				return;
			}
		}
	} elsif(ref($address) eq 'Gedcom::Record') {
		$place = getaddress($address);
		$address = undef;
	}

	if((!defined($address)) &&
	   ($place !~ /USA$/) && ($place !~ /United States$/) &&
	   ($place =~ /(.+),\s*(.+,\s*.+,\s*.+)$/)) {
		$address = $1;
		$place = $2;
	}

	# Google maps (and possibly others) sometimes works better with full names
	if($address) {
		if($address =~ /(.+)\sSt\.?$/) {
			$address = "$1 Street";
		} elsif($address =~ /(.+)\sAve\.?$/) {
			$address = "$1 Avenue";
		} elsif($address =~ /(.+)\sRd\.?$/) {
			$address = "$1 Road";
		}
	}

	my $there = $params{'there'};

	if($there && ($place eq $there)) {
		if($address) {
			if($place =~ /^(.+?),.+,/) {
				if($params{'nopreposition'}) {
					return " $address, $1";
				} else {
					return " at $address, $1";
				}
			}
		} else {
			return ' there';
		}
	}

	# The more consistent the data, the fewer lookups on Geocoders and the smoother the English output
	if($place =~ /(.+?)\s*United States$/i) {
		$place = "$1 USA";
	} elsif($place =~ /States\s*$/) {
		complain({ person => $params{'person'}, warning => "Unexpected text at the end of the place '$place'" });
	}

	if($params{'person'}) {
		validate_place({ person => $params{'person'}, place => $place });
	}

	if($birth_country && (!$opts{'T'}) && ($place =~ /(.+),\s*\Q$birth_country\E$/i)) {
		$place = $1;
	}

	if((!$opts{'T'}) && $place =~ /^\d/) {
		if(my $places_printed = $params{'places_printed'}) {
			$places_printed->{" at$place"} = 1;
			if($place =~ /(.+),(.+?),(.+?),(.+?),(.+?)$/) {
				if($places_printed->{" in$3,$4,$5"}) {
					$places_printed->{"in $1,$2,$3"} = 1;
					return " at $1,$2,$3";
				}
			}
			if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
				$places_printed->{" in$2,$3,$4"} = 1;
			}
		}
		return " at $place";
	}

	if($place eq 'USA') {
		return ' in the USA';
	}

	if($address) {
		if($params{'nopreposition'}) {
			$place = " $address, $place";
		} else {
			$place = " at $address, $place";
		}
	} elsif($params{'nopreposition'}) {
		$place = " $place";
	} else {
		$place = " in $place";
	}

	# Only print the town if the location has already been printed
	if((!$opts{'T'}) && (my $places_printed = $params{'places_printed'})) {
		if($places_printed->{$place} && $place =~ /^(.+?),/) {
			return $1;
		}
		if($place =~ /(.+),(.+?),(.+?),(.+?)$/) {
			my $str = "$2,$3,$4";
			if($params{'person'}) {
				validate_place({ person => $params{'person'}, place => $place });
			}
			if($places_printed->{" in$str"}) {
				if(($4 eq ' USA') || ($4 eq ' Canada')) {
					return "$1,$3";
				}
				return $address ? "$1,$2" : "$1 in$2";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2";
			}
			$str = "$3,$4";
			if($places_printed->{" in$str"}) {
				return "$1,$2,$3";
			}
			if($places_printed->{" at$str"}) {
				return "$1,$2,$3";
			}
			$places_printed->{" in$str"} = 1;
			$places_printed->{" in$2,$3,$4"} = 1;
		} elsif($place =~ /(.+),(.+),(.+)$/) {
			if($places_printed->{" in$2,$3"}) {
				# We did place, county, country before, so just
				# return place, county
				return "$1,$2";
			}
			$places_printed->{" in$2,$3"} = 1;
		}
		$places_printed->{$place} = 1;
	}
	return $place;
}

sub getaddress {
	my $address = shift;

	my $rc;

	if(my $city = $address->city()) {
		$rc = $city;
	}
	if(my $state = $address->state()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $state;
	}
	if(my $country = $address->country()) {
		if($rc) {
			$rc .= ', ';
		}
		$rc .= $country;
	}

	return $rc;
}

sub notes
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record = $params{'record'};
	my $paragraph = $params{'paragraph'};
	my @notes = $record->get_record('note');

	# my @deathnotes = get_value({ person => $person, value => 'death note' });
	my $rc = $record->get_value();
	$rc .= '.' if($rc && !scalar(@notes));

	foreach my $note(@notes) {
		if($note) {
			if(ref($note) eq 'Gedcom::Record') {
				$note = $note->full_value();	# Include CONC records
			} else {
				complain("Note record is just description ($note), infomation may have been lost");
			}
			$note =~ s/\r//g;
			if(!$paragraph) {
				$note =~ tr/\n/ /;
			}
			$note =~ s/\s+$//g;
			$note =~ s/\.$//;
			if($paragraph) {
				if($rc) {
					$rc .= "\n";
				}
				if($opts{'B'}) {
					$rc .= '    ';
				} else {
					$rc .= "\t";
				}
			} elsif($rc) {
				$rc .= '; ';
			}
			$rc .= "$note.";
		} else {
			complain('Notes field is empty');
		}
	}
	if((!defined($rc)) || (length($rc) == 0)) {
		return;
	}
	$rc =~ s/ $//;
	$rc =~ s/\xe2\x80\x9c/"/g;	# left quotation
	$rc =~ s/\xe2\x80\x9d/"/g;	# right quotation
	$rc =~ s/\x80"/"/g;
	$rc =~ s/\xe2\x80\x99/'/g;
	$rc =~ s/[\x93\x94]/"/g;
	$rc =~ s/[\x91\x92]/'/g;
	$rc =~ s/[\xc2\xe2]//g;

	if(defined($ENV{'LANG'})) {
		if($ENV{'LANG'} =~ /^en_US/) {
			$rc = Lingua::EN::ABC::b2a($rc);
		} elsif($ENV{'LANG'} =~ /^en_GB/) {
			$rc = Lingua::EN::ABC::a2b($rc);
		}
	}

	# my $region;

	# if($record) {
		# $region = $record->place();
	# }
	# if(!$region && (my $person = $params{'person'})) {
		# $region = get_value({ person => $person, value => 'birth place' });
		# if(!$region) {
			# $region = get_value({ person => $person, value => 'death place' });
		# }
	# }
	# if($region && ($region =~ /^.+,\s([[a-z\s]+)$/i)) {
		# if($1 =~ /(England|United Kingdom)/i) {
			# $region = 'gb';
		# } elsif($1 =~ /(USA|US|United States)/i) {
			# $region = 'us';
		# } elsif(lc($1) eq 'Canada') {
			# $region = 'ca';
		# }
	# }

	# my @call_details = caller(0);
	# print 'line ', $call_details[2], ">>>>$region\n";
	# foreach my $k(keys %params) {
		# print "\t$k\n";
	# }
	# if(($rc !~ /^was /i) && (my @hr = $textgeocoder->geocode(scantext => $rc, region => $region))) {
		# print STDERR Data::Dumper->new([\@hr])->Dump();
	# }
	return $rc;
}

sub validate_place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	if(!$place) {
		print STDERR "\n";
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		die 'place is not optional';
	}

	$place =~ s/^\s+//;
	$place =~ s/^at\s+//;
	if(defined($places{$place})) {
		return $places{$place};
	}

	# US and Canada are more logical, using city,county,state,country, than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if($place =~ /(.*),\s*Independent Cities\s*(.*)/i) {
			$place = "$1$2";
		}
		$place =~ s/^(in|at)\s//;
		if(defined($places{$place})) {
			return $places{$place};
		}
		# my $ap;
		# my $p = $place;
		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# $ap = Lingua::EN::AddressParse->new(country => 'US', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
		# } elsif($place =~ /England$/) {
			# $ap = Lingua::EN::AddressParse->new(country => 'GB', auto_clean => 1, force_case => 1, force_post_code_flag => 0);
			# $p .= ', United Kingdom';
		# }
		# if($ap) {
			# my $error = $ap->parse("$address, $p");
			# print $ap->report();
		# }

		# if(($place =~ /USA$/) || ($place =~ /United States$/)) {
			# if(my $href = Geo::StreetAddress::US->parse_location($place)) {
				# if($href->{'state'} && !$us->{code2state}{$href->{'state'}} && !$us->{state2code}{$href->{'state'}) {
				# die $href->{'state'};
					# complain({ person => $params{'person'}, warning => "Unknown state in $place" });
				# }
			# }
		# }
		if((($place =~ /USA$/) || ($place =~ /United States$/)) && ($place =~ /^.+,\s*([\w\s]+),[\w\s]+$/)) {
			my $state = uc($1);
			if((!$us->{code2state}{$state}) && !$us->{state2code}{$state}) {
				complain({ person => $params{'person'}, warning => "Unknown state '$state' in $place" });
			}
		}

		my $town = $place;
		if($place =~ /,\s*(.+,.+,.+,.+)$/) {
			# Use only the town part
			$town = $1;
		}
		if($opts{'w'}) {
			# Strange locations in censuses
			if($town =~ /Royal Navy/) {
				return 0;
			}
			# Force wantarray for improved caching in
			# G:C:L
			my @locations = $geocoder->geocode($town);
			if(scalar(@locations) == 0) {
				# Don't die because there are many
				# false positives as locations
				# may no longer exist
				if(my $person = $params{'person'}) {
					if($opts{'W'}) {
						print STDERR $person->as_string({ include_years => 1 }), ": unknown location '$place'\n";
					} else {
						my @call_details = caller(0);
						warn colored($person->as_string({ include_years => 1 }) . ": unknown location '$place' at line " . $call_details[2], 'red');
					}
				} else {
					if($opts{'W'}) {
						print STDERR "Unknown location $place\n";
					} else {
						warn colored("Unknown location $place", 'red');
					}
				}
				$places{$place} = 0;
				$places{$town} = 0;
				return 0;
			}
		}
		$places{$town} = 1;
	}
	$places{$place} = 1;
	return 1;
}

sub places_are_the_same
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $record1 = $params{'first'};
	my $record2 = $params{'second'};

	die 'first is not optional' unless $record1;
	die 'second is not optional' unless $record2;

	my $place1 = $record1->place();
	return 0 unless(defined($place1));
	my $place2 = $record2->place();
	return 0 unless(defined($place2));

	if(my $person = $params{'person'}) {
		validate_place({ person => $person, place => $place1 });
		validate_place({ person => $person, place => $place2 }) unless($place1 eq $place2);
	}

	if(my $address = $record1->address()) {
		$place1 = "$address, $place1";
	}
	if(my $address = $record2->address()) {
		$place2 = "$address, $place2";
	}
	return $place1 eq $place2;
}

sub print_sibling_baptism
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $siblings = $params{'siblings'};
	my $date = $params{'date'};
	my $birthdate = $params{'birthdate'};

	return '' if(scalar(@{$siblings}) == 0);

	my @onsameday;
	foreach my $sibling(@{$siblings}) {
		my $dateofsiblingbaptism = get_value({ person => $sibling, value => 'baptism date' });
		if($dateofsiblingbaptism && ($dateofsiblingbaptism eq $date)) {
			push @onsameday, $sibling;
		}
	}
	my $allsamesex = 1;
	if(scalar(@onsameday) > 1) {
		foreach my $sibling(@onsameday) {
			if($sibling->sex() ne $person->sex()) {
				$allsamesex = 0;
				last;
			}
		}
		if($allsamesex) {
			foreach my $sibling(@onsameday) {
				my $dateofsiblingbirth = get_value({ person => $sibling, value => 'birth date' });
				if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
					$allsamesex = 0;	# Fudge to force special twin handler
				}
			}
		}
	} else {
		$allsamesex = 0;
	}

	if($allsamesex) {
		return ', the same day as ' . lcfirst($person->possessive()) . ' ' .
			($onsameday[0]->sex() eq 'M' ? 'brothers ' : 'sisters ') .
			Lingua::EN::Inflect::WORDLIST((map { $_->given_names() } @onsameday), {final_sep => ''});
	}
	my $count = 0;
	my $rc = '';
	foreach my $sibling(@onsameday) {
		if($count == 0) {
			$rc .= ', the same day as ';
		} elsif($count < (scalar(@onsameday) - 1)) {
			$rc .= ', ';
		} elsif($count == (scalar(@onsameday) - 1)) {
			$rc .= ' and ';
		}
		$rc .= lcfirst($person->possessive()) . ' ';
		my $dateofsiblingbirth = get_value({ person => $sibling, value => 'birth date' });
		if($dateofsiblingbirth && $birthdate && ($dateofsiblingbirth eq $birthdate)) {
			$rc .= 'twin ';
		}
		$rc .= ($sibling->sex() eq 'M' ? 'brother ' : 'sister ') .
			$sibling->given_names();
		$count++;
	}
	return $rc;
}

sub complain
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'warning'} = shift;
	}

	die "What do you want to say?" unless($params{'warning'});

	if($opts{'f'}) {
		my @call_details = caller(0);
		if($params{'person'}) {
			die $params{'person'}->as_string(), ': ', ucfirst($params{'warning'}), ' at line ', $call_details[2];
		}
		die ucfirst($params{'warning'}), ' at line ', $call_details[2];
	}

	if($opts{'w'}) {
		$params{'caller'} = 1;
		red_warning(%params);
	}
}

sub red_warning
{
	if($opts{'w'}) {
		my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

		my @call_details = caller($params{'caller'} || 0);
		if($opts{'B'}) {
			my $text = $pdfpage->text();
			$text->fillcolor('red');

			my $message;
			if($params{'person'}) {
				$message = $params{'person'}->as_string(middle_names => 1) . ': ' . $params{'warning'};
			} else {
				$message = params{'warning'};
			}
			if(!pdfprint(string => $message, text => $text, pdfpage => $pdfpage)) {
				$text->textend();

				$pdfpage = PDFPage->new();

				$text = $pdfpage->text();
				$text->font($pdf->corefont('Times-Roman'), 12);
				$text->fillcolor('red');
				pdfprint(string => $message, text => $text, pdfpage => $pdfpage);
			}
			$text->fillcolor('black');
		} elsif($params{'person'}) {
			if($opts{'W'}) {
				print STDERR $params{'person'}->as_string(middle_names => 1), ': ', $params{'warning'}, "\n";
			} else {
				warn colored(['red'], $params{'person'}->as_string(), ': ', $params{'warning'}, ' at line ', $call_details[2]);
			}
		} else {
			if($opts{'W'}) {
				print STDERR lcfirst($params{'warning'}), "\n";
			} else {
				warn colored(['red'], $params{'warning'}, ' at line ', $call_details[2]);
			}
		}
		if($params{'stack_trace'}) {
			my $i = 0;
			while((my @call_details = (caller($i++)))) {
				print STDERR "\t", colored($call_details[1] . ':' . $call_details[2] . ' calling function ' . $call_details[3], 'red'), "\n";
			}
		}
	}
}

# Cache gedcom values
sub get_value
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	if($fetcher) {
		my $args = {
			object => $params{'person'},
			message => 'get_value',
			arg => $params{'value'}
		};

		# Doesn't use the prefetching feature, but will automatically cache which is nice
		# $fetcher->prime($args);
		return $fetcher->get($args);
	}
	return $params{'person'}->get_value($params{'value'});
}

sub get_source
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $args = {
		object => $params{'gedcom'},
		message => 'get_source',
		arg => $params{'source'}
	};

	# Doesn't use the prefetching feature, but will automatically cache which is nice
	# $fetcher->prime($args);
	return $fetcher->get($args);
}

sub must_predate
{
	return unless($opts{'w'});

	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $date = $params{'date'};
	my $predate = $params{'predate'};

	return unless($params{'predate'} && $params{'date'});

	my $d1 = $dfn->parse_datetime($date);
	my $d2 = $dfn->parse_datetime($predate);

	if($d1->year() > $d2->year()) {
		if($opts{'f'}) {
			die $person->as_string(), ": Something is wrong with the date $date which should be before $predate";
		}
		red_warning({
			person => $person,
			warning => "something is wrong with the date $date which should be before $predate"
		});
	}
}

sub is_alive
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	if($person->get_record('death') || get_value({ person => $person, value => 'death date' })) {
		return 0;
	}
	if($person->get_record('burial')) {
		return 0;
	}
	my $dob = get_value({ person => $person, value => 'birth date' });

	if(!defined($dob)) {
		return 0;	# Err on the side of caution
				# TODO: Look at children's lifespan for a clue
	}

	my $year = (localtime)[5];
	$year += 1900 if($year < 1900);

	if(($dob =~ /^\d{3,4}$/) && ($dob < ($year - 100))) {
		return 0;
	}
	if($dob =~ /^abt (\d{4})$/i) {
		$dob = $1;
	}
	if(($dob =~ /^\d/) && ($dob !~ /[a-z]$/i)) {
		if(my $d = date_parser_cached(date => $dob)) {
			$d = $dfn->parse_datetime($d->{'canonical'});
			if($d->strftime('%Y') < ($year - 120)) {
				return 0;
			}
		}
	}
	return 1;
}

sub make_filename_from_person
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};

	my $rc = $person->as_string(include_years => 1);
	$rc =~ tr/ /-/s;
	$rc =~ tr/"/'/s;
	$rc =~ s/--+/-/g;
	# $rc =~ s/--/-/g;
	$rc =~ s/-$//;

	return "$rc.html";
}

# Parse Gedcom format dates
# Genealogy::Gedcom::Date is expensive, so cache results
sub date_parser_cached
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	my $date = $params{'date'};

	if($all_dates{$date}) {
		print "$date is already known\n" if($opts{'v'});
		return $all_dates{$date};
	}
	print "Parse date $date\n" if($opts{'v'});
	my $d;
	eval {
		$d = $date_parser->parse(date => $date);
	};
	if($d && (ref($d) eq 'ARRAY')) {
		$d = @{$d}[0];
		$all_dates{$date} = $d;
	}
	return $d;
}

# Try hard to convert a Gedcom date to a DateTime object.
# If a date range is given, return a two element array in array context, or undef in scalar context
sub date_to_datetime
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'date'} = shift;
	}

	if(my $date = $params{'date'}) {
		if($date =~ /^\s*(\d{3,4})\s*\-\s*(\d{3,4})\s*$/) {
			complain("Changing date '$date' to 'bet $1 and $2'");
			$date = "bet $1 and $2";
		}
		if($date =~ /^bet (.+) and (.+)/i) {
			if(wantarray) {
				return date_to_datetime($1), date_to_datetime($2);
			}
			return;
		}
		if($date !~ /^\d{3,4}$/) {
			if(($date =~ /^\d/) && (my $d = date_parser_cached($date))) {
				return $dfn->parse_datetime($d->{'canonical'});
			}
			if(($date !~ /^(Abt|ca?)/i) && ($date =~ /^[\w\s]+$/)) {
				# ACOM exports full month names and non-standard format dates e.g. U.S. format MMM, DD YYYY
				if(my $rc = $dfn->parse_datetime($date)) {
					return $rc;
				}
				complain(warning => "Can't parse date '$date'");
			}
		}
	}
	undef;
}

sub descendents
{
	my $person = shift;

	my @list;
	if(my $l = shift) {
		@list = @{$l};
	}

	my @children = $person->children();
	if(scalar(@children)) {
		foreach my $child(@children) {
			push @list, $child;
			# my @spouses = $child->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendents($child, \@list);
		}
	}

	return @list;
}

sub ancestors
{
	my $person = shift;

	my @list;
	if(my $l = shift) {
		@list = @{$l};
	}

	if(my $mother = $person->mother()) {
		push @list, $mother;
		@list = ancestors($mother, \@list);
		my @siblings = $mother->siblings();
		foreach my $sibling(@siblings) {
			push @list, $sibling;
			# my @spouses = $sibling->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendents($sibling, \@list);
		}
	}
	if(my $father = $person->father()) {
		push @list, $father;
		@list = ancestors($father, \@list);
		my @siblings = $father->siblings();
		foreach my $sibling(@siblings) {
			push @list, $sibling;
			# my @spouses = $sibling->spouse();
			# if(scalar(@spouses)) {
				# push @list, @spouses;
			# }
			@list = descendents($sibling, \@list);
		}
	}

	return @list;
}

# Print the text in "string" to the "text" object returned from PDF::API2->text()
sub pdfprint
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $pdfpage = $params{'pdfpage'};

	die 'pdfprint: pdfpage is not optional' if(!defined($pdfpage));

	if($pdfpage->full()) {
		print "pdfprint: full returned true\n" if($opts{'v'});
		return 0;
	}

	my $indent = ($params{'noindent'}) ? '' : '    ';

	my @lines = split(/\n/, wrap($indent, '', ($params{'string'})));

	if(scalar(@lines) >= $pdfpage->linesleft() - 1) {
		print 'pdfprint: ', scalar(@lines), ' >= ', ($pdfpage->linesleft() - 1), "\n" if($opts{'v'});

		return 0;
	}

	my $text = $pdfpage->text();
	my $x = $params{'x'} || 40;

	foreach my $line (@lines) {
		$text->translate($x, $pdfpage->newline());
		if($params{'centre'}) {
			$text->text_center($line);
		} else {
			$text->text($line);
		}
	}
	return 1;
}

# Inspired by Tree::Family.  That module doesn't quite do what I want, so
# I've mercilessly re-used the ideas of what to do from it.
sub print_graphviz
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $colour = $params{'colour'};
	my $profile_image = $params{'profile_image'};

	if(!defined($colour)) {
		my $gender = get_value({ person => $person, value => 'sex' }) || $person->sex();
		if(defined($gender)) {
			$gender = $gender;
		} else {
			if($opts{'f'}) {
				die "\n", $person->as_string(), ": unknown sex\n";
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => 'unknown sex' });
			}
			$gender = 'M';	# Avoid "Use of uninitialized value" in Tree::Family
		}
		$colour = ($gender eq 'M' ? '#093AB5' : '#C666B8');
	}

	print $fout $person->{'xref'}, ' [shape=box,fontsize="10",',
		"color=\"$colour\",";

	# if($params{'format'} eq 'dynamic') {
		# print $fout 'href="?page=people&entry=', $person->{'xref'}, '",';
	# } else {
		# print $fout 'href="', make_filename_from_person(person => $person), '",';
	# }

	my $label = $person->as_string();
	my $dob = get_value({ person => $person, value => 'birth date' });
	my $dod = get_value({ person => $person, value => 'death date' });

	my $thumbnail;

	# If you get 'Warning: No loadimage plugin for "jpeg:cairo"', do this
	# instead:
	# if(0) {
	if($profile_image && (defined($dod) || $opts{'l'})) {
		if(defined($dob)) {
			$dob .= "<TR><TD>b. $dob</TD></TR>";
		} else {
			$dob = '';
		}
		if(defined($dod)) {
			$dod .= "<TR><TD>d. $dod</TD></TR>";
		} else {
			$dod = '';
		}
		# Create a thumbnail
		my $image = Image::Magick->new();
		$image->read($profile_image);
		my ($thumb, $x, $y) = Image::Magick::Thumbnail::create($image, 100);
		my @thumbname = File::Basename::fileparse($profile_image);
		# use PNG to try to avoid
		#	'Warning: No loadimage plugin for "jpeg:cairo"'
		$thumbname[0] =~ s/\.jpg$/.png/;
		$thumbnail = "thumbs/$thumbname[0]";
		$thumb->Write($thumbnail);

		# FIXME: TABLE isn't supported by Graphviz
		print $fout "label=<<TABLE border=\"0\" cellborder=\"0\"><TR><TD><IMG SRC=\"thumbs/$thumbname[0]\" scale=\"true\"/></TD></TR><TR><TD>$label</TD></TR>$dob$dod</TABLE>>",
			",labelloc=b";

		# print $fout ",image=\"$profile_image\",labelloc=b";

		chmod 0444, $thumbnail;
	} elsif(defined($dod) || $opts{'l'}) {
		if(defined($dob)) {
			$label .= "\\nb. $dob";
		}
		if(defined($dod)) {
			$label .= "\\nd. $dod";
		}
		print $fout "label=\"$label\"";
	} else {
		print $fout "label=\"$label\"";
	}

	print $fout "];\n";

	return $thumbnail;
}

sub print_graphviz_generation
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $fout = $params{'fout'};
	my $person = $params{'person'};
	my $rank = $params{'rank'} + 1;
	my $maxrank = $params{'maxrank'} + 1;
	$params{'rank'} = $rank;

	return if($maxrank && ($rank >= $maxrank));

	print $fout "} subgraph children$rank { rank=\"$rank\"; ";
	print_graphviz({ person => $person, fout => $fout, format => 'dynamic' });

	if(($rank > 1) && (my $father = $person->father())) {
		print $fout $father->{'xref'}, ' -> ', $person->{'xref'}, ";\n";
	}

	if($person->sex() eq 'M') {
		# my @children = $person->children();
		my @children;
		foreach my $f($person->fams()) {
			@children = (@children, $f->children());
		}
		if(scalar(@children) > 0) {
			# TODO: sort by date of birth
			foreach my $child(@children) {
				if($opts{'l'} || !is_alive(person => $child)) {
					$params{'person'} = $child;
					print_graphviz_generation(\%params);
				}
			}
		}
	}
}

sub get_all_residences
{
	my %params;

	if(ref($_[0]) eq 'HASH') {
		%params = %{$_[0]};
	} elsif(scalar(@_) % 2 == 0) {
		%params = @_;
	} else {
		$params{'person'} = shift;
	}

	my $person = $params{'person'};

	my @residences = $person->residence();
	my @rc;
	my $index = 0;
	foreach my $residence(@residences) {
		$index++;
		if(!ref($residence)) {
			my $r = $person->tag_record('RESI', $index);
			if(ref($r) eq 'Gedcom::Record') {
				$residence = $r;
			}
		}
		if(ref($residence) eq 'Gedcom::Record') {
			push @rc, $residence;
		}
	}
	my @events = $person->event();
	$index = 0;
	foreach my $event(@events) {
		$index++;
		if(!ref($event)) {
			my $e = $person->tag_record('EVEN', $index);
			if(ref($e) eq 'Gedcom::Record') {
				$event = $e;
			}
		}
		next if(ref($event) ne 'Gedcom::Record');
		my $type = $event->type();
		next if(!defined($type));
		if(($type =~ /^Census U[KS] \d{4}$/) || ($type eq 'Register UK 1939') || ($type eq 'Hospitalisation')) {
			push @rc, $event;
		}
	}

	return @rc;
}

sub journey
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $person = $params{'person'};
	my $arrival = $params{'arrival'};
	my $departure = $params{'departure'};

	my $rc;
	my $yod;
	my $yoa;
	my $dod = $departure->date();
	my $doa = $arrival->date();
	my $only_have_departure_year;
	if($doa && $dod && ($doa =~ /(\d{3,4})/)) {
		$yoa = $1;
		$doa =~ s/\s?\d{3,4}//;
		if($dod =~ /(\d{3,4})/) {
			$yod = $1;
			$dod =~ s/\s?\d{3,4}//;
			if($dod =~ /^\d/) {
				$dod = "on $dod";
			} else {
				$dod = "during $yod";
				$only_have_departure_year = 1;
			}
			if($doa =~ /^\d/) {
				$doa = "on $doa";
			} elsif($yoa == $yod) {
				$doa = 'later that same year';
			} else {
				$doa = "during $yoa";
			}
		}
	}
	if($dod) {
		if($yod && $yoa && ($yod == $yoa)) {
			$rc = " In $yod, " . lc($person->pronoun());
		} else {
			$rc = $person->pronoun();

			# $yod = year({ person => $person, record => $departure });
			# $yoa = year({ person => $person, record => $arrival });
		}

		if($ENV{'LANG'} =~ /^en_US/) {
			$rc .= ' traveled';
		} else {
			$rc .= ' travelled';
		}

		if(defined($departure->place())) {
			$rc .= ' from' . place({ person => $person, record => $departure, nopreposition => 1 });
			if(my $notes = notes(record => $departure)) {
				$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
				$notes =~ s/\.$//;
				$rc .= " ($notes)";
			}
		} else {
			complain({ person => $person, warning => 'Departure record has no location' });
		}
		if(defined($arrival->place())) {
			$rc .= ' to' . place({ person => $person, record => $arrival, nopreposition => 1 });
			if(my $notes = notes(record => $arrival)) {
				$notes = lcfirst($notes) unless($notes =~ /^[A-Z]{2}/);
				$notes =~ s/\.$//;
				$rc .= " ($notes)";
			}
		} else {
			complain({ person => $person, warning => 'Arrival record has no location' });
		}

		if(defined($dod) && !$only_have_departure_year) {
			$rc .= ", departing $dod and";
		}

		$rc .= " arriving $doa";
	}

	return $rc;
}

sub count_descendents_at_level
{
	my $person = shift;
	my $level = shift;

	my $count = 0;
	foreach my $child($person->children()) {
		if($level == 1) {
			$count++;
		} else {
			$count += count_descendents_at_level($child, $level - 1);
		}
	}
	return $count;
}

# Compare two dates. Approximate dates are compared.
# TODO: handle when only months are known
sub datecmp
{
	my $left = shift;
	my $right = shift;

	if((!defined($left)) || !defined($right)) {
		print STDERR "\n";
		if(!defined($left)) {
			print STDERR "BUG: left not defined\n";
		}
		if(!defined($right)) {
			print STDERR "BUG: right not defined\n";
		}
		my $i = 0;
		while((my @call_details = caller($i++))) {
			print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
		}
		return 0;
	}
	if(!ref($left)) {
		if($left =~ /^(Abt|ca?)\s+(.+)/i) {
			$left = $2;
		}
		if($left !~ /^\d{3,4}$/) {
			my $rc = $dfg->parse_datetime($left);
			if(!defined($rc)) {
				print STDERR "Date parse failure: ($left):\n";
				my $i = 0;
				while((my @call_details = caller($i++))) {
					print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
				}
				return 0;
			}
			$left = $rc;
		}
	}
	if(!ref($right)) {
		if($right =~ /^(Abt|ca?)\s+(.+)/i) {
			$right = $2;
		}
		if($right =~ /^\d{3,4}$/) {
			if(ref($left)) {
				return $left->year() <=> $right;
			} else {
				return $left <=> $right;
			}
		}
		# if(!$dfg->parse_datetime($right)) {
			# my $i = 0;
			# while((my @call_details = caller($i++))) {
				# print STDERR "\t", colored($call_details[2] . ' of ' . $call_details[1], 'red'), "\n";
			# }
			# die $right;
		# }
		$right = $dfg->parse_datetime($right);
	}
	if((!ref($left)) && ref($right)) {
		return $left <=> $right->year();
	}
	if(ref($left) && (!ref($right))) {
		return $left->year() <=> $right;
	}

	return $left <=> $right;
}


# FIXME: once RT127603 has been fixed
sub Geo::Coder::PlaceFinder::ua
{
	my $self = shift;
	my $ua = shift;

	if($ua = shift) {
		return $self->{_ua} = $ua;
	}

	return $self->{_ua};
}

1;

package PDFPage;

our $pixelsperline = 16;	# point size 12

sub new
{
	my $class = shift;

	$pixelsperline = 16;

	return bless { y => 750, page => $pdf->page() }, $class;
}

sub newline
{
	my $self = shift;

	$self->{'y'} -= $pixelsperline;

	if($self->{'y'} <= 10) {
		my $i = 0;
		while((my @call_details = (caller($i++)))) {
			print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
		}
		die 'BUG: fallen too low vertically; y = ' . $self->{'y'};
	}

	return $self->{'y'};
}

sub full
{
	my $self = shift;

	return $self->{'y'} <= $pixelsperline * 2;
}

sub linesleft
{
	my $self = shift;

	return ($self->{'y'} / $pixelsperline) - 1;	# round fractions down
}

sub y
{
	my $self = shift;
	my $y = shift;

	if($y) {
		if($y <= 10) {
			my $i = 0;
			while((my @call_details = (caller($i++)))) {
				print STDERR "\t", $call_details[1], ':', $call_details[2], ' calling function ', $call_details[3], "\n";
			}
			die "BUG: fallen too low vertically; y = $y";
		}

		$self->{'y'} = $y;
	}

	return $self->{'y'};
}

sub page
{
	my $self = shift;

	return $self->{'page'};
}

sub text
{
	my $self = shift;

	if(!defined($self->{'text'})) {
		my $text = $self->{'text'} = $self->{'page'}->text();
		$text->textstart();
	}
	return $self->{'text'};
}

sub DESTROY {
	if(defined($^V) && ($^V ge 'v5.14.0')) {
		return if ${^GLOBAL_PHASE} eq 'DESTRUCT';	# >= 5.14.0 only
	}
	my $self = shift;

	if($self->{'text'}) {
		$self->{'text'}->textend();
	}
}
# TODO: DESTROY - add a page number
