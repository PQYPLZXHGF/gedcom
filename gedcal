#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2012-2015, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# TODO: Use Gedcom::Date - needs a couple of bug fixes in that first though
# FIXME: -a Goes through the entire file once for each day without remembering
#	anything

# -a: all days otherwise just today
# -b: only print birthdays
# -d: give a detailed lifetime information about the person
# -D: only print anniversaries of deaths
# -f: treat warnings as fatals, implies -w
# -l: ignore living people
# -v: verbose - for debugging
# -w: print warning about invalid day

use strict;
use warnings;
# use diagnostics;
# use warnings::unused;

use Gedcom;
use Genealogy::Gedcom::Date;
use Date::Parse;	# For strptime
use Getopt::Std;
use Geo::Coder::OSM;
use Term::ANSIColor;

my %opts;

getopts('abdDfh:lwv', \%opts);
die "Usage: $0 [ -a ] [ -b ] [ -d ] [ -D ] [ -f ] [ -h home-person-name ] [ -l ] [ -w ] filename\n" unless($ARGV[0]);

my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);

my $me;
my %warned;
my %printed;
my %places;

if($opts{h}) {
	$me = $ged->get_individual($opts{h});
	unless($me) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	}
}

if($opts{'f'}) {
	$opts{'w'} = 1;
}

if($opts{'w'}) {
	# Cache calls to openstreetmap
	require File::Spec;
	File::Spec->import();

	require HTTP::Cache::Transparent;
	HTTP::Cache::Transparent->import();

	my $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache');

	HTTP::Cache::Transparent::init( {
	BasePath => $cachedir . '/http-cache-transparent',
	# Verbose => 1,
	NoUpdate => 60 * 60,
	MaxAge => 15 * 24} ) || die "$0/cache: $!";
}

my $date_parser = Genealogy::Gedcom::Date->new();
my $geocoder = Geo::Coder::OSM->new();
my $year = (localtime)[5];
$year += 1900 if($year < 1900);

if($opts{a}) {
	die '-b and -a should not be given together' if($opts{'b'});
	die '-D and -a should not be given together' if($opts{'D'});

	foreach my $month(0..11) {
		foreach my $day(1..29) {
			generate(day => $day, month => $month);
		}
		if($month == 1) {
			next;
		}
		generate(day => 30, month => $month);
		if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
			generate(day => 31, month => $month);
		}
	}
	generate(day => -1, month => -1);
} elsif($opts{'b'}) {
	die '-b and -d should not be given together' if($opts{'d'});
	die '-b and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	if($opts{'D'}) {
		print "Today's birthdays:\n";
	}
	generate(day => $day, month => $month, onlybirthdays => 1, onlydeaths => 0);
	if($opts{'D'}) {
		print "Today's anniversaries of deaths:\n";
		generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1);
	}
} elsif($opts{'D'}) {
	die '-D and -d should not be given together' if($opts{'d'});
	die '-D and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	if($opts{'b'}) {
		print "Today's anniversaries of deaths:\n";
	}
	generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1);
	if($opts{'b'}) {
		print "Today's birthdays:\n";
		generate(day => $day, month => $month, onlybirthdays => 1, onlydeaths => 0);
	}
} else {
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month);
}

sub generate {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $day = $params{'day'};
	my $month = $params{'month'};

	my $onlybirthdays = $params{'onlybirthdays'};
	my $onlydeaths = $params{'onlydeaths'};

	die "BUG: onlydeaths and onlybirths given" if($onlydeaths && $onlybirthdays);

	foreach my $person($ged->individuals()) {
	# foreach my $person(sort { $a->get_value('last name') cmp $b->get_value('last name') } $ged->individuals()) {
		next if($me && ($person eq $me));

		my $xref = $person->{'xref'};
		next if($printed{$xref});

		# Gather the information on this person
		my $name = $person->name();

		print "$name\n" if($opts{v});
		if($name =~ /(.+?)\s*[SJ]r\.?/i) {
			$name = $1;
		}
		if($name =~ /(.+)Mc\s+(.+)/) {
			$name = "$1$2";
		}
		$name =~ s/[\(\)]//g;

		print "Sanity check $name\n" if($opts{v});
		next unless($name =~ /^(.+)\s+\/(.+)\/(.*)/);
		print "Sanity check $name passed\n" if($opts{v});

		my ($firstname, $middlename, $lastname, $suffix);
		$firstname = lc($1);
		$lastname = lc($2);
		$suffix = $3;

		next unless($firstname && $lastname);

		if($firstname =~ /(.+)?\s+(.+)/) {
			$firstname = $1;
			unless($2 eq $lastname) {
				$middlename = $2;
			}
		}

		$suffix =~ s/^\s+//;

		my $dob;
		eval {
			$dob = $person->get_value('birth date');
		};
		if($@) {
			warn "Can't parse record for $firstname $lastname";
			next;
		}

		next if($onlybirthdays && !defined($dob));

		my $dod = $person->get_value('death date') || $person->get_value('burial date');

		next if($onlydeaths && !defined($dod));

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			$yod = $1;
		}

		# unless($dob) {
			# $dob = $person->get_value('baptism date');
		# }

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			$yob = $1;
		} elsif($dob) {
			if($opts{'w'} && !$warned{$person}) {
				if($opts{'f'}) {
					die $person->name(), ": invalid date of birth $dob\n";
				}
				warn $person->name(), ": invalid date of birth $dob\n";
				$warned{$person} = 1;
			}
			$yob = undef;
		} else {
			$yob = $dob;
		}

		if((!defined($opts{l})) && (!defined($yod)) && defined($yob) && ($yob > 1900)) {
			# Assuming living if we don't have a date of death and
			# they were born after 1900
			next;
		}

		# Change surname of a married woman
		my $sex = $person->get_value('sex');
		my $maidenname;
		if(defined($sex) && ($sex eq 'F')) {
			my $husband = $person->husband();
			if(defined($husband)) {
				my $hname = $husband->name();
				if($hname =~ /(.+)\s*Jr\.?/i) {
					$hname = $1;
				}
				if($hname =~ /(.+)Mc\s+(.+)/) {
					$hname = "$1$2";
				}
				# print $person->name(), " married to $hname\n";
				if($hname =~ /^.+\s+\/(.+)\/$/) {
					$maidenname = $lastname;
					$lastname = lc($1);
				}
			}
		}

		# Remove alternatives - go with the first
		if($lastname =~ /(.+)[\/\\]/) {
			$lastname = $1;
		}
		if($firstname =~ /(.+)[\/\\]/) {
			$firstname = $1;
		}

		unless($dob || $dod || $opts{a}) {
			next;
		}

		print 'Checking ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

		my $print = 0;
		my $aob;
		my $aod;

		if($dob && ($dob !~ /^\d{4}$/)) {
			my @btime = strptime($dob . ' 12:00');
			if(defined($btime[3]) && ($btime[3] == $day) && ($btime[4] == $month) && $btime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aob = (localtime)[5] - $btime[5];
					if($aob <= 0) {
						$aob += 1900;
					}
				}
			}
		}
		next if($onlybirthdays && !defined($aob));
		if($dod && ($dod !~ /^\d{4}$/)) {
			my @dtime = strptime($dod . ' 12:00');
			if(defined($dtime[3]) && ($dtime[3] == $day) && ($dtime[4] == $month) && $dtime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aod = (localtime)[5] - $dtime[5];
					if($aod <= 0) {
						$aod += 1900;
					}
				}
			}
		}
		next if($onlydeaths && !defined($aod));

		next unless($print or ($day == -1));

		$printed{$xref} = 1;

		print $person->as_string({
			include_years => 1,
			nee => 1,
			middle_names => 1,
		}), "\n";

		my $spouse = $person->spouse();
		my $birth = $person->get_record('birth');
		my $death = $person->get_record('death');
		my $printed_death_year;
		my $end_of_sentence;
		my $printed_birth_year;
		my $birth_dt;
		my $death_dt;
		my $mother;
		my $father;
		my $dom;

		if($opts{d}) {
			# my $first_name = (split(/ /, $person->given_names()))[0];
			my $first_name = ucfirst($firstname);
			$first_name =~ s/\s.+//;
			my $printed_first_name;
			my $printed_comma;
			my $any_output;
			my $space_count;

			if(!$opts{a}) {
				if($me) {
					my $relationship = $me->relationship($person);
					if($relationship) {
						print "\tYour $relationship $first_name";
						$any_output = 1;
						$printed_first_name = 1;
					} elsif($person->spouse()) {
						$relationship = $me->relationship($person->spouse());
						if($relationship) {
							print "\t$first_name, the";
							print ' ', (($sex eq 'F') ? 'wife of' : 'husband of'), " your $relationship,";
							$printed_first_name = 1;
							$any_output = 1;
							$printed_comma = 1;
						}
					}
					# if($aod) {
						# print ' ', lcfirst($person->pronoun());
					# } else {
						# print "\n$first_name";
					# }
				}

				if($aob || $aod) {
					unless($any_output) {
						print "\t$first_name";
						$any_output = 1;
						$printed_first_name = 1;
					}
				}
				if($aob && $aod) {
					print " was born $aob years ago and died $dod years ago today";
					$printed_birth_year = 1;
				} elsif($aob) {
					print " was born $aob years ago today";
					$printed_birth_year = 1;
				} elsif($aod) {
					print " died $aod ", ($aod == 1) ? 'year' : 'years', ' ago today';
					$printed_death_year = 1;
				}
			} elsif($dob) {
				print $first_name;
				$any_output = 1;
				$printed_first_name = 1;

				if($me) {
					my $relationship = $me->relationship($person);
					if($relationship) {
						if($relationship) {
							print ", your $relationship,";
							$any_output = 1;
							$printed_first_name = 1;
						} elsif($person->spouse()) {
							$relationship = $me->relationship($person->spouse());
							if($relationship) {
								print ', the';
								print ' ', (($sex eq 'F') ? 'wife of' : 'husband of'), " your $relationship,";
								$printed_first_name = 1;
								$any_output = 1;
								$printed_comma = 1;
							}
						}
					}
				}
				print ' was born ', year($dob);
				$any_output = 1;
				$printed_first_name = 1;
				$printed_birth_year = 1;
			}
			if($printed_birth_year) {
				if($birth && $birth->place()) {
					my $pob = $birth->place();
					print " in $pob";
					$any_output = 1;
					validate_place($pob);
				}
			} elsif($printed_death_year) {
				my $pod = place($death);
				if($pod) {
					print " $pod";
					$any_output = 1;
				}
			}
			if($birth && !$printed_birth_year) {
				print ' having been born';
				my $pob = $birth->place();
				if(defined($pob)) {
					if($death) {
						my $pod = $death->place();
						if($pod && ($pob eq $pod)) {
							print ' there';
						} else {
							print " in $pob";
							validate_place($pob);
						}
					} else {
						print " in $pob";
						validate_place($pob);
					}
				}
				if($dob) {
					if(!$person->get_value('birth date')) {
						# Use the baptism date for approximation
						if($dob =~ /(\d{4})$/) {
							print " around $1";
						} else {
							print " around $dob";
						}
					} else {
						print ' ', year($dob);
					}
				}
				$any_output = 1;
			}
			if($any_output) {
				print '.  ';
				$space_count = 2;
				$any_output = 1;
				$end_of_sentence = 1;
			}

			my @father = $person->father();
			$father = $father[0];
			my @mother = $person->mother();
			$mother = $mother[0];
			if($father || $mother) {
				unless($space_count) {
					print ' ';
				}
				print $person->pronoun(), ' was the child of';

				if($father) {
					print ' ', $father->as_string();
					if($mother) {
						print ' and';
					}
				}
				if($mother) {
					print ' ', $mother->as_string({ give_maidenname => 0 });
				}
				$end_of_sentence = 0;
				$any_output = 1;
			}
			# TODO: $person->marriage_count()
			if($spouse) {
				if($end_of_sentence) {
					print $person->pronoun();
				} elsif($dod && (!$aod) || $person->get_value('baptism date')) {
					if($any_output) {
						print ',';
					} else {
						print $first_name;
					}
				} elsif($any_output) {
					print ', and';
				} else {
					print $first_name;
				}
				$dom = $person->get_value('marriage date') || $spouse->get_value('marriage date');
				if((!$opts{l}) || $dod || $dom || $person->get_value('burial date')) {
					print ' was';
				} elsif($yob && ($yob <= 1900)) {
					print ' was';
				} else {
					print ' is';
				}
				print ' married to ', $spouse->as_string();
				if($dom) {
					if($dom =~ /^\d/) {
						print " on $dom";
					} else {
						print " in $dom";
					}
				}
				my $marriage = $person->get_record('marriage') || $spouse->get_record('marriage');
				if($marriage && $marriage->place()) {
					my $pom = $marriage->place();
					print " at $pom";
					validate_place($pom);
				}
				$end_of_sentence = 0;
			}
		} elsif(defined($dob) && (!$onlydeaths) && !$onlybirthdays) {
			my $d;
			if(($dob !~ /^\d{4}$/) && ($dob =~ /^\d/)) {
				eval {
					$d = $date_parser->parse_date_value(date => $dob);
				};
			}
			if($d) {
				$birth_dt = $d->{one_date};
				print "\tBorn: ", $birth_dt->strftime('%x');
			} else {
				if($@) {
					if($opts{'f'}) {
						die $@;
					}
					if($opts{'w'}) {
						warn $@;
					}
				}
				print "\tBorn: $dob";
				# RT 106705
				$date_parser = Genealogy::Gedcom::Date->new();
			}
			print "\n" if(defined($dod));
		}
		my $just_printed_death = 0;
		if(defined($dod) && (!$onlydeaths) && !$onlybirthdays) {
			if($opts{d}) {
				if($aod) {
					if($death && !$printed_death_year) {
						my $pod = $death->place();
						if($pod) {
							print " and died in $pod";
							validate_place($pod);
						}
					}
				} else {
					if($mother || $father || ($spouse && !$end_of_sentence)) {
						my $burial = $person->get_record('burial');
						if($burial && $burial->place()) {
							print ', died ';
						} else {
							print ', and died ';
						}
					} else {
						print '.  ' if(!$end_of_sentence);
						print $person->pronoun(), ' died ';
					}
					if(!$person->get_value('death date')) {
						# Use the burial date for approximation
						if($dod =~ /(\d{4})$/) {
							print "around $1";
						} else {
							print "around $dod";
						}
					} else {
						print year($dod);
					}
					if($death) {
						my $pod = $death->place();
						if($pod) {
							print " in $pod";
							validate_place($pod);
						}
					}
					$just_printed_death = 1;
				}
			} else {
				my $d;
				if(($dod !~ /^\d{4}$/) && ($dod =~ /^\d/)) {
					eval {
						$d = $date_parser->parse_date_value(date => $dod);
					};
				}
				if($d) {
					$death_dt = $d->{one_date};
					print "\tDied: ", $death_dt->strftime('%x');
				} else {
					if($@) {
						if($opts{'f'}) {
							die $@;
						}
						if($opts{'w'}) {
							warn $@;
						}
					}
					print "\tDied: $dod";
					# RT 106705
					$date_parser = Genealogy::Gedcom::Date->new();
				}
			}
		}
		if($opts{'d'}) {
			$end_of_sentence = 0;
			$dob = $person->get_value('baptism date');
			my $baptism;
			if($dob) {
				$baptism = $person->get_record('baptism');
				if($dod) {
					print '.  ', $person->pronoun();
				} else {
					print ' and';
				}
				print ' was';
				if($baptism && $baptism->place() && $death && $death->place() && ($baptism->place() eq $death->place())) {
					print ' also';
				}
				if($ENV{'LANG'} =~ /^en_US/) {
					print ' baptized ';
				} else {
					print ' baptised ';
				}
				if($baptism) {
					my $pob = $baptism->place();
					if($pob) {
						if((!$dod) && $birth && $birth->place() && ($baptism->place() eq $birth->place())) {
							print 'there ';
						} else {
							print "at $pob ";
						}
						validate_place($pob);
					}
					print 'on ', $baptism->date();
				} else {
					print "on $dob";
				}
				$end_of_sentence = 0;
			}
			my $doburial = $person->get_value('burial date');
			if($doburial) {
				my $burial = $person->get_record('burial');
				if(($dob || $spouse) && !$dom) {
					print ' and ';
					print 'was ' if($just_printed_death)
				} else {
					print '.  ', $person->pronoun();
					if($burial->date()) {
						print ' was ';
					} else {
						print ' is ';
					}
				}
				print 'buried ';
				if($burial) {
					if($burial->place()) {
						if($baptism && $baptism->place() && ($burial->place() eq $baptism->place())) {
							print 'there ';
						} else {
							my $pob = $burial->place();
							print "at $pob ";
							validate_place($pob);
						}
						$just_printed_death = 1;
					}
					print year($burial->date(), $death_dt), '.';
				} else {
					print "on $doburial.";
				}
				$end_of_sentence = 1;
			}
			my $family = $person->fams();
			if((defined($family)) && $family->number_of_children()) {
				if(!$just_printed_death) {
					print ' with whom ', lcfirst($person->pronoun());
				} else {
					print '. ' if(!$end_of_sentence);
					print ' ', $person->pronoun();
				}
				if((!$opts{'l'}) || ($yob && ($year > $yob + 100))) {
					print ' had ';
				} else {
					print $dod ? ' had ' : ' has ';
				}

				my $child_count = $family->number_of_children();
				if($child_count == 1) {
					print "1 child, ";
					print $family->children()->given_names();
				} else {
					print "$child_count children, ";

					my @children_names = map { $_->given_names() } $family->children();

					my $children = join(', ', @children_names);
					substr($children, rindex($children, ', '), 2, ' and ');
					print $children;
				}
				print ".\n";
				foreach my $child($family->children()) {
					my $dob = $child->get_value('birth date');
					if($dob) {
						print "\t" unless($opts{'a'});
						print "\t", $child->given_names();
						print ' was born ';
						if($dob =~ /^Abt\.?\s*(.+)/i) {
							print "around $1";
						} elsif(($dob =~ /^\d{4}$/) || ($dob !~ /^\d/)) {
							print "in $dob";
						} else {
							my $d;
							eval {
								$d = $date_parser->parse_date_value(date => $dob);
							};
							if($d) {
								$d = $d->{one_date};
								print 'on ', $d->strftime('%x');
								if($birth_dt && ($d < $birth_dt)) {
									if($opts{'f'}) {
										die 'Born after parent had died';
									}
									if($opts{'w'}) {
										warn 'Born after parent had died';
									}
								}
							} else {
								if($@) {
									if($opts{'f'}) {
										die $@;
									}
									if($opts{'w'}) {
										warn $@;
									}
								}
								$date_parser = Genealogy::Gedcom::Date->new();
							}
						}
						print ".\n";
					} elsif($child->get_value('baptism date')) {
						print "\t" unless($opts{'a'});
						print "\t", $child->given_names();
						print ' was born c';
						print $child->get_value('baptism date');
						print ".\n";
					}
				}
			} else {
				print '.' if(!$end_of_sentence);
				print "\n";
			}
		}
		if($opts{'d'}) {
			if($person->get_value('note')) {
				print "Note: ", $person->get_value('note'), "\n";
			}
			if($opts{'a'}) {
				print '-' x 80;
			}
		}
		print "\n" unless($onlybirthdays || $onlydeaths);
	}
}

sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $surname = $self->surname();

	if($args{'nee'}) {
		my $sex = $self->get_value('sex');
		if(defined($sex) && ($sex eq 'F')) {
			my $husband = $self->husband();
			if(defined($husband)) {
				$surname = $husband->surname();
			}
		}
	}

	my $rc;
	if($self->given_names()) {
		foreach my $name(split(' ', $self->given_names())) {
			if($rc) {
				$rc .= ' ';
			}
			$rc .= normalize_name($name);
			last unless($args{'middle_names'});
		}
	}

	if($surname) {
		$rc .= ' ' . normalize_name($surname);
	}

	if($args{'nee'} && ($surname ne $self->surname())) {
		$rc .= ' (nee ' . normalize_name($self->surname()) . ')';
	}

	if($args{'include_years'}) {
		my $dob = $self->get_value('birth date');

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			$yob = $1;
		} else {
			$dob = $self->get_value('baptism date');
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = $self->get_value('death date');

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			$yod = $1;
		} else {
			$dod = $self->get_value('burial date');
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ';

		if($yob) {
			$rc .= $yob;
		}

		$rc .= ' -';

		if($yod) {
			$rc .= " $yod";
		}
	}

	return $rc;
}

sub normalize_name
{
	my $name = shift;

	my $rc;
	foreach my $word(split(/-| |'/, lc($name))) {
		$rc .= '-' if($rc && ($name =~ /-/));
		$rc .= "'" if($rc && ($name =~ /'/));
		$rc .= ' ' if($rc && ($name =~ / /));
		$rc .= ucfirst($word);
	}

	return $rc;
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	my $sex = $self->get_value('sex');

	if(defined($sex)) {
		if($sex eq 'F') {
			return 'She';
		} elsif($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship
{
	my $self = shift;
	my $other = shift;

	my @ancestors1 = $self->ancestors();
	return unless @ancestors1;

	my $sex = $other->get_value('sex');
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		if($opts{'f'}) {
			die "\n", $other->as_string(), ":  unknown sex\n";
		}
		if($opts{'w'}) {
			warn "\n", $other->as_string(), ":  unknown sex\n";
		}
		return;
	}

	foreach my $person1(@ancestors1) {
		if($person1 eq $other) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title = ($sex eq 'M') ? 'father' : 'mother';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} else {
				return 'great-' x ($steps - 2) . "grand$title";
			}
			die $other->as_string(), ': Bug - not a direct ancestor';
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	my $p1level = 0;
	foreach my $person1(@ancestors1) {
		if($p1level++ >= 8) {
			last;
		}
		my $p2level = 0;
		foreach my $person2(@ancestors2) {
			if($p2level++ >= 8) {
				last;
			}
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }
			if($person1 eq $person2) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				return if($steps1 > 7);
				my $steps2 = stepsabove($other, $person2, 0);
				return if($steps2 > 7);

				# It would be nice to do this as an algorithm, but this will do
				# e.g. 2, 1 is uncle
				my %male_relationships = (
					1 << 8 | 1 => 'brother',
					2 << 8 | 1 => 'uncle',
					3 << 8 | 1 => 'great-uncle',
					4 << 8 | 1 => 'great-great-uncle',
					2 << 2 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					3 << 8 | 2 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					4 << 8 | 2 => 'first cousin twice-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 4 => 'second cousin once-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
				);
				my %female_relationships = (
					1 << 8 | 1 => 'sister',
					2 << 8 | 1 => 'aunt',
					3 << 8 | 1 => 'great-aunt',
					4 << 8 | 1 => 'great-great-aunt',
					2 << 2 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					3 << 8 | 2 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					4 << 8 | 2 => 'first cousin twice-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 4 => 'second cousin once-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
				);

				my $rc = ($sex eq 'M') ?
					$male_relationships{($steps1 << 8) | $steps2} :
					$female_relationships{($steps1 << 8) | $steps2};
				# print "$steps1, $steps2\n" unless($rc);
				return $rc;
			}
		}
	}
}

sub stepsabove
{
	my $me = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if($target eq $me) {
		return $count;
	}
	if($me->father()) {
		my $rc = stepsabove($me->father(), $target, $count + 1);
		return $rc if($rc != -1);
	}
	if($me->mother()) {
		my $rc = stepsabove($me->mother(), $target, $count + 1);
		return $rc if($rc != -1);
	}
	return -1;
}

sub year
{
	my $string = shift;
	my $must_postdate = shift;

	if($string =~ /^\d{4}$/) {
		return "in $string";
	}
	if($string =~ /^Abt\.?\s*(.+)/i) {
		return "around $1";
	}
	if($string =~ /^\d/) {
		my $d;
		eval {
			$d = $date_parser->parse_date_value(date => $string);
		};
		if($d) {
			$d = $d->{one_date};
			if($must_postdate) {
				if($opts{'f'}) {
					die "Something is wrong" if($d < $must_postdate);
				}
				if($opts{'w'}) {
					warn colored('Something is wrong', 'red') if($d < $must_postdate);
				}
			}
			return 'on ', $d->strftime('%x');
		}
		if($@) {
			if($opts{'f'}) {
				die $@;
			}
			if($opts{'w'}) {
				warn $@;
			}
		}
		return "on $string";
	}
	return "in $string";
}

sub place
{
	my $place = shift;
	return unless($place);

	$place = $place->place();
	return unless($place);

	validate_place($place);

	if($place =~ /^\d/) {
		return "at $place";
	}
	return "in $place";
}

sub validate_place
{
	my $place = shift;

	if($places{$place}) {
		return $places{$place};
	}

	# US and Canada are more logical in city,county,state,country than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if(!$geocoder->geocode($place)) {
			# Don't die because there are many
			# false positives as locations
			# may no longer exist
			warn colored("Unknown location $place", 'red');
			$places{$place} = 0;
			return 0;
		}
	}
	$places{$place} = 1;
	return 1;
}
