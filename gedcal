#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2012-2015, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# TODO: Use Gedcom::Date - needs a couple of bug fixes in that first though
# FIXME: -a Goes through the entire file once for each day without remembering
#	anything

# -a: all days otherwise just today
# -d: give a detailed lifetime information about the person
# -l: ignore living people
# -v: verbose - for debugging
# -w: print warning about invalid day

use strict;
use warnings;
# use diagnostics;

use Gedcom;
use Gedcom::Date;
use Date::Parse;	# For strptime
use Getopt::Std;
use Data::Compare;

my %opts;

getopts('adh:lwv', \%opts);
die "Usage: $0 [ -a ] [ -d ] [ -h home-person-name] [ -l ] [ -w ] filename\n" unless($ARGV[0]);

my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);

my $me;
if($opts{h}) {
	$me = $ged->get_individual($opts{h});
	unless($me) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	}
}

if($opts{a}) {
	foreach my $month(0..11) {
		foreach my $day(1..29) {
			generate(day => $day, month => $month);
		}
		if($month == 1) {
			next;
		}
		generate(day => 30, month => $month);
		if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
			generate(day => 31, month => $month);
		}
	}
} else {
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month);
}

sub generate {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $day = $params{'day'};
	my $month = $params{'month'};

	foreach my $person($ged->individuals()) {
		next if(Compare($person, $me) == 1);

		# Gather the information on this person
		my $name = $person->name();

		print "$name\n" if($opts{v});
		if($name =~ /(.+?)\s*[SJ]r\.?/i) {
			$name = $1;
		}
		if($name =~ /(.+)Mc\s+(.+)/) {
			$name = "$1$2";
		}
		$name =~ s/[\(\)]//g;

		print "Sanity check $name\n" if($opts{v});
		next unless($name =~ /^(.+)\s+\/(.+)\/(.*)/);
		print "Sanity check $name passed\n" if($opts{v});

		my ($firstname, $middlename, $lastname, $suffix);
		$firstname = lc($1);
		$lastname = lc($2);
		$suffix = $3;

		next unless($firstname && $lastname);

		if($firstname =~ /(.+)?\s+(.+)/) {
			$firstname = $1;
			unless($2 eq $lastname) {
				$middlename = $2;
			}
		}

		$suffix =~ s/^\s+//;

		my $dob;
		eval {
			$dob = $person->get_value('birth date');
		};
		if($@) {
			warn "Can't parse record for $firstname $lastname";
			next;
		}

		my $dod = $person->get_value('death date') ? $person->get_value('death date') : $person->get_value('burial date');

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			$yod = $1;
		}

		# unless($dob) {
			# $dob = $person->get_value('baptism date');
		# }

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			$yob = $1;
		} elsif($dob) {
			if($opts{w}) {
				print $person->name(), ": invalid date of birth $dob\n";
			}
			$yob = undef;
		} else {
			$yob = $dob;
		}

		if((!defined($opts{l})) && (!defined($yod)) && defined($yob) && ($yob > 1900)) {
			# Assuming living if we don't have a date of death and
			# they were born after 1900
			next;
		}

		# Change surname of a married woman
		my $sex = $person->get_value('sex');
		my $maidenname;
		if(defined($sex) && ($sex eq 'F')) {
			my $husband = $person->husband();
			if(defined($husband)) {
				my $hname = $husband->name();
				if($hname =~ /(.+)\s*Jr\.?/i) {
					$hname = $1;
				}
				if($hname =~ /(.+)Mc\s+(.+)/) {
					$hname = "$1$2";
				}
				# print $person->name(), " married to $hname\n";
				if($hname =~ /^.+\s+\/(.+)\/$/) {
					$maidenname = $lastname;
					$lastname = lc($1);
				}
			}
		}

		# Remove alternatives - go with the first
		if($lastname =~ /(.+)[\/\\]/) {
			$lastname = $1;
		}
		if($firstname =~ /(.+)[\/\\]/) {
			$firstname = $1;
		}

		unless($dob || $dod) {
			next;
		}

		my %params = (
			dob => $yob,
			dod => $yod,
			firstname => $firstname,
			middlename => $middlename,
			lastname => $lastname,
			maidenname => $maidenname,
			suffix => $suffix,
		);

		print 'Checking ', stringify(\%params), "\n" if($opts{'v'});

		my $print = 0;

		my $aob;
		my $aod;

		if($dob && ($dob !~ /^\d{4}$/)) {
			my @btime = strptime($dob . ' 12:00');
			if(defined($btime[3]) && ($btime[3] == $day) && ($btime[4] == $month) && $btime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aob = (localtime)[5] - $btime[5];
					if($aob <= 0) {
						$aob += 1900;
					}
				}
			}
		}
		if($dod && ($dod !~ /^\d{4}$/)) {
			my @dtime = strptime($dod . ' 12:00');
			if(defined($dtime[3]) && ($dtime[3] == $day) && ($dtime[4] == $month) && $dtime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aod = (localtime)[5] - $dtime[5];
					if($aod <= 0) {
						$aod += 1900;
					}
				}
			}
		}

		if($print) {
			print $person->as_string({
				include_years => 1,
				nee => 1,
				middle_names => 1,
			}), "\n";

			my $sex = $person->get_value('sex');
			my $spouse = $person->spouse();
			my $birth = $person->get_record('birth');

			if($opts{d}) {
				# my $first_name = (split(/ /, $person->given_names()))[0];
				my $first_name = ucfirst($firstname);
				my $printed_first_name;
				my $printed_comma;
				my $any_output;

				if(!$opts{a}) {
					if($aob && $aod) {
						print "\t$first_name was born $aob years ago and died $dod years ago today.";
						$printed_first_name = 1;
					} elsif($aob) {
						print "\tBorn $aob years ago today, ";
					} elsif($aod) {
						print "\t$first_name died $aod years ago today. ";
						$printed_first_name = 1;
					}
					$any_output = 1;
				}

				my $relationship;
				if($me) {
					$relationship = $me->relationship($person);
					if($relationship) {
						if($aob || $aod) {
							print "$first_name, your";
							$printed_first_name = 1;
						} else {
							print 'Your';
						}
						print " $relationship";
						$any_output = 1;
					} elsif($person->spouse()) {
						$relationship = $me->relationship($person->spouse());
						if($relationship) {
							if($aob) {
								print "the";
							} else {
								print 'The';
							}
							print ' ', (($sex eq 'F') ? 'wife of' : 'husband of'), " your $relationship";
							$any_output = 1;
						}
					}
					if($printed_first_name) {
						print ',';
						$printed_comma = 1;
						$any_output = 1;
					}
					# if($aod) {
						# print ' ', lcfirst($person->pronoun());
					# } else {
						# print "\n$first_name";
					# }
				}

				my @father = $person->father();
				my $father = $father[0];
				my @mother = $person->mother();
				my $mother = $mother[0];
				if($father || $mother) {
					unless($printed_first_name) {
						if($any_output) {
							print ' ';
						}
						print $first_name;
					}
					if($aob || $opts{a}) {
						print ' was the child of';
					} else {
						print ' to';
					}
					if($father) {
						print ' ', $father->as_string();
						if($mother) {
							print ' and';
						}
					}
					if($mother) {
						print ' ', $mother->as_string({ give_maidenname => 0 });
					}
				}
				if(defined($dob)) {
					unless($aob) {
						if($father || $mother || $relationship) {
							unless($printed_comma) {
								print ',';
							}
							print ' ', lcfirst($person->pronoun());
						} elsif($opts{a}) {
							if($relationship) {
								print ' ';
							}
							print $first_name;
						} else {
							print $person->pronoun();
						}
						print ' was born ';
						if($dob =~ /^\d{4}$/) {
							print "in $dob";
						} elsif($dob =~ /^Abt\.?\s*(.+)/i) {
							print "around $1";
						} else {
							print "on $dob";
						}
					}
					if($birth && $birth->place()) {
						if($aob) {
							if((!$father) && (!$mother)) {
								print $first_name;
							} else {
								print '. ', $person->pronoun();
							}
							print ' was born';
						} elsif($opts{a} && !$dob) {
							if($father || $mother) {
								print '. ', $person->pronoun();
							} else {
								print $firstname;
							}
							print ' was born';
						}
						print ' in ', $birth->place();
					}
				}
				# TODO: $person->marriage_count()
				if($spouse) {
					if($dod) {
						print ',';
					} else {
						print ' and';
					}
					if($dod || $spouse->get_value('death date') || $spouse->get_value('burial date') || $person->get_value('marriage date')) {
						print ' was';
					} else {
						print ' is';
					}
					print ' married to ', $spouse->as_string();
					my $dom = $person->get_value('marriage date') || $spouse->get_value('marriage date');
					if($dom) {
						print " on $dom";
					}
					my $marriage = $person->get_record('marriage') || $spouse->get_record('marriage');
					if($marriage && $marriage->place()) {
						print ' at ', $marriage->place();
					}
				}
			} elsif(defined($dob)) {
				# my $d = Gedcom::Date::parse($dob);
				# if($d) {
					# print "\tBorn: $d->as_text()\n";
				# } else {
					print "\tBorn: $dob";
				# }
			}
			if(defined($dod)) {
				if($opts{d}) {
					print ' and died ';
					if(!$person->get_value('death date')) {
						# Use the burial date for approximation
						if($dod =~ /(\d{4})$/) {
							print "around $1.";
						} else {
							print "around $dod.";
						}
					} elsif($dod =~ /^Abt\s*(.+)/i) {
						print "around $1.";
					} elsif($dod =~ /^\d{4}$/) {
						print "in $dod.";
					} else {
						print "on $dod.";
					}
				} else {
					# my $d = Gedcom::Date::parse($dob);
					# if($d) {
						# print "\tDied: $d->as_text()\n";
					# } else {
						print "\n\tDied: $dod";
					# }
				}
			}
			if($opts{'d'}) {
				$dob = $person->get_value('baptism date');
				my $baptism;
				if($dob) {
					$baptism = $person->get_record('baptism');
					if($dod) {
						print '  ', $person->pronoun();
					} else {
						print ' and';
					}
					print ' was baptised ';
					if($baptism) {
						if($baptism->place()) {
							if((!$dod) && $birth && $birth->place() && ($baptism->place() eq $birth->place())) {
								print 'there ';
							} else {
								print 'at ', $baptism->place(), ' ';
							}
						}
						print 'on ', $baptism->date();
					} else {
						print "on $dob";
					}
				}
				my $doburial = $person->get_value('burial date');
				if((defined($dob) && !defined($doburial)) || !defined($dod)) {
					print '.';
				}
				if($doburial) {
					my $burial = $person->get_record('burial');
					if($dob) {
						print ' and ';
					} else {
						print '  ', $person->pronoun(), ' was ';
					}
					print 'buried ';
					if($burial) {
						if($burial->place()) {
							if($baptism && $baptism->place() && ($burial->place() eq $baptism->place())) {
								print 'there ';
							} else {
								print 'at ', $burial->place(), ' ';
							}
						}
						print 'on ', $burial->date(), ".";
					} else {
						print "on $doburial.";
					}
				}
				my $family = $person->fams();
				if((defined($family)) && $family->number_of_children()) {
					print '  ', $person->pronoun(), ' ';
					print $dod ? 'had ' : 'has ';

					my $child_count = $family->number_of_children();
					if($child_count == 1) {
						print "1 child, ";
						print $family->children()->given_names();
					} else {
						print "$child_count children, ";

						my @children_names = map { $_->given_names() } $family->children();

						my $children = join(', ', @children_names);
						substr($children, rindex($children, ', '), 2, ' and ');
						print $children;
					}
					print ".\n";
					foreach my $child($family->children()) {
						if($child->get_value('birth date')) {
							print "\t" unless($opts{'a'});
							print "\t", $child->given_names();
							print ' was born ';
							my $dob = $child->get_value('birth date');
							if($dob =~ /^\d{4}$/) {
								print "in $dob";
							} elsif($dob =~ /^Abt\.?\s*(.+)/i) {
								print "around $1";
							} else {
								print "on $dob";
							}
							print ".\n";
						} elsif($child->get_value('baptism date')) {
							print "\t" unless($opts{'a'});
							print "\t", $child->given_names();
							print ' was born c';
							print $child->get_value('baptism date');
							print ".\n";
						}
					}
				} else {
					print "\n";
				}
			}
			if($opts{'a'} && $opts{'d'}) {
				print '-' x 80;
			}
			print "\n";
		}
	}
}

# Pretty print a person
sub stringify {
	my $params = shift;

	my $dob = $$params{dob};
	my $dod = $$params{dod};
	my $firstname = $$params{firstname};
	my $lastname = $$params{lastname};
	my $middlename = $$params{middlename};
	my $maidenname = $$params{maidenname};
	my $suffix = $$params{suffix};

	my $rc = ucfirst($lastname);

	if($firstname) {
		my $f = ucfirst($firstname);
		$rc .= ", $f";
		if($middlename) {
			$f = ucfirst($middlename);
			$rc .= " $f";
		}
	}

	if($maidenname && ($maidenname ne $lastname)) {
		foreach(split / /, $maidenname) {
			if($_ ne $lastname) {
				my $m .= ucfirst($_);
				$rc .= " (nee $m)";
				last;
			}
		}
	}

	if($suffix) {
		$rc .= " $suffix";
	}

	$rc .= ' ';

	if($dob) {
		$rc .= $dob;
	}

	$rc .= '-';

	if($dod) {
		$rc .= $dod;
	}

	return $rc;
}

sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $surname = $self->surname();

	if($args{'nee'}) {
		my $sex = $self->get_value('sex');
		if(defined($sex) && ($sex eq 'F')) {
			my $husband = $self->husband();
			if(defined($husband)) {
				$surname = $husband->surname();
			}
		}
	}

	my $rc;
	if($surname) {
		$rc = normalize_name($surname);
	}

	if($self->given_names()) {
		if($surname) {
			$rc .= ',';
		}

		foreach my $name(split(' ', $self->given_names())) {
			if($rc) {
				$rc .= ' ';
			}
			$rc .= normalize_name($name);
			last unless($args{'middle_names'});
		}
	}

	if($args{'nee'} && ($surname ne $self->surname())) {
		$rc .= ' (nee ' . normalize_name($self->surname()) . ')';
	}

	if($args{'include_years'}) {
		my $dob = $self->get_value('birth date');

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			$yob = $1;
		} else {
			$dob = $self->get_value('baptism date');
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = $self->get_value('death date');

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			$yod = $1;
		} else {
			$dod = $self->get_value('burial date');
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ';

		if($yob) {
			$rc .= $yob;
		}

		$rc .= ' -';

		if($yod) {
			$rc .= " $yod";
		}
	}

	return $rc;
}

sub normalize_name
{
	my $name = shift;

	return ucfirst(lc($name));
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	my $sex = $self->get_value('sex');

	if(defined($sex)) {
		if($sex eq 'F') {
			return 'She';
		} elsif($sex eq 'M') {
			return 'He';
		} else {
			return 'They';
		}
	} else {
		return 'They';
	}
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship
{
	my $self = shift;
	my $other = shift;

	my $sex = $other->get_value('sex');

	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		if($opts{w}) {
			print "\n", $other->as_string(), ":  unknown sex\n";
		}
		return;
	}

	my @ancestors1 = $self->ancestors();
	return unless @ancestors1;

	foreach my $person1(@ancestors1) {
		# if($s1 eq $s2) {
		if(Compare($person1, $other)) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title = ($sex eq 'M') ? 'father' : 'mother';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} else {
				return 'great-' x ($steps - 2) . "grand$title";
			}
			die $other->as_string(), ': Bug - not a direct ancestor';
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	foreach my $person1(@ancestors1) {
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }
			if(Compare($person1, $person2)) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				my $steps2 = stepsabove($other, $person2, 0);

				return if ($steps1 > 7) || ($steps2 > 7);

				# It would be nice to do this as an algorithm, but this will do
				# e.g. 2, 1 is uncle
				my %male_relationships = (
					1 << 8 | 1 => 'brother',
					2 << 8 | 1 => 'uncle',
					3 << 8 | 1 => 'great-uncle',
					4 << 8 | 1 => 'great-great-uncle',
					2 << 2 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					3 << 8 | 2 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					4 << 8 | 2 => 'first cousin twice-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 4 => 'second cousin once-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
				);
				my %female_relationships = (
					1 << 8 | 1 => 'sister',
					2 << 8 | 1 => 'aunt',
					3 << 8 | 1 => 'great-aunt',
					4 << 8 | 1 => 'great-great-aunt',
					2 << 2 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					3 << 8 | 2 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					4 << 8 | 2 => 'first cousin twice-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 4 => 'second cousin once-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
				);

				my $rc = ($sex eq 'M') ?
					$male_relationships{($steps1 << 8) | $steps2} :
					$female_relationships{($steps1 << 8) | $steps2};
				# print "$steps1, $steps2\n" unless($rc);
				return $rc;
			}
		}
	}
}

sub stepsabove
{
	my $me = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if(Compare($me, $target)) {
		return $count;
	}
	if($me->father()) {
		my $rc = stepsabove($me->father(), $target, $count + 1);
		return $rc if($rc != -1);
	}
	if($me->mother()) {
		my $rc = stepsabove($me->mother(), $target, $count + 1);
		return $rc if($rc != -1);
	}
	return -1;
}
