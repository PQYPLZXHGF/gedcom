#!/usr/bin/env perl

# Author Nigel Horne: njh@bandsman.co.uk
# Copyright (C) 2015, Nigel Horne

# Usage is subject to licence terms.
# The licence terms of this software are as follows:
# Personal single user, single computer use: GPL2
# All other users (including Commercial, Charity, Educational, Government)
#	must apply in writing for a licence for use from Nigel Horne at the
#	above e-mail.

# FIXME: -a Goes through the entire file once for each day without remembering
#	anything
# TODO: print -d events in chronological order, that may also simplify the logic

# -a: all days otherwise just today
# -b: only print birthdays
# -d: give a detailed lifetime information about the person
# -D: only print anniversaries of deaths
# -f: treat warnings as fatals, implies -w
# -l: include living people
# -v: verbose - for debugging
# -w: print warning about unlikely data - a sort of lint for Gedcom files

use strict;
use warnings;
# use diagnostics;
# use warnings::unused;

use Gedcom;
use Genealogy::Gedcom::Date;
use Date::Parse;	# For strptime
use Getopt::Std;
use Geo::Coder::OSM;
use Term::ANSIColor;
use Lingua::EN::NameCase;
use Lingua::EN::NameParse;
use Lingua::EN::Numbers::Ordinate;

my %opts;

getopts('abdDfh:lwv', \%opts);
die "Usage: $0 [ -a ] [ -b ] [ -d ] [ -D ] [ -f ] [ -h home-person-name ] [ -l ] [ -w ] filename\n" unless($ARGV[0]);

my $ged = Gedcom->new(gedcom_file => $ARGV[0], read_only => 1);

my $me;
my %warned;
my %printed;
my %places;

if($opts{h}) {
	$me = $ged->get_individual($opts{h});
	unless($me) {
		die "$0: Can't find '$opts{h}' in $ARGV[0]";
	}
}

if($opts{'f'}) {
	$opts{'w'} = 1;
}

if($opts{'w'}) {
	# Cache calls to openstreetmap
	require File::Spec;
	File::Spec->import();

	require HTTP::Cache::Transparent;
	HTTP::Cache::Transparent->import();

	my $cachedir = File::Spec->catfile(File::Spec->tmpdir(), 'cache');

	HTTP::Cache::Transparent::init({
		BasePath => $cachedir . '/http-cache-transparent',
		# Verbose => 1,
		NoUpdate => 60 * 60 * 24,
		MaxAge => 30 * 24
	}) || die "$0/cache: $!";
}

my $date_parser = Genealogy::Gedcom::Date->new();
my $geocoder = Geo::Coder::OSM->new();
my $nameparser = Lingua::EN::NameParse->new();

my $year = (localtime)[5];
$year += 1900 if($year < 1900);

if($opts{a}) {
	die '-b and -a should not be given together' if($opts{'b'});
	die '-D and -a should not be given together' if($opts{'D'});

	foreach my $month(0..11) {
		foreach my $day(1..29) {
			generate(day => $day, month => $month);
		}
		if($month == 1) {
			next;
		}
		generate(day => 30, month => $month);
		if(($month == 0) || ($month == 2) || ($month == 4) || ($month == 6) || ($month == 7) || ($month == 9) || ($month == 11)) {
			generate(day => 31, month => $month);
		}
	}
	generate(day => -1, month => -1);
} elsif($opts{'b'}) {
	die '-b and -d should not be given together' if($opts{'d'});
	die '-b and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	if($opts{'D'}) {
		print "Today's birthdays:\n";
	}
	generate(day => $day, month => $month, onlybirthdays => 1, onlydeaths => 0);
	if($opts{'D'}) {
		print "Today's anniversaries of deaths:\n";
		generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1);
	}
} elsif($opts{'D'}) {
	die '-D and -d should not be given together' if($opts{'d'});
	die '-D and -a should not be given together' if($opts{'a'});
	my($day, $month) = (localtime)[3,4];
	if($opts{'b'}) {
		print "Today's anniversaries of deaths:\n";
	}
	generate(day => $day, month => $month, onlybirthdays => 0, onlydeaths => 1);
	if($opts{'b'}) {
		print "Today's birthdays:\n";
		generate(day => $day, month => $month, onlybirthdays => 1, onlydeaths => 0);
	}
} else {
	my($day, $month) = (localtime)[3,4];
	generate(day => $day, month => $month);
}

sub generate {
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $day = $params{'day'};
	my $month = $params{'month'};

	my $onlybirthdays = $params{'onlybirthdays'};
	my $onlydeaths = $params{'onlydeaths'};

	die "BUG: onlydeaths and onlybirths given" if($onlydeaths && $onlybirthdays);

	foreach my $person($ged->individuals()) {
	# foreach my $person(sort { $a->get_value('last name') cmp $b->get_value('last name') } $ged->individuals()) {
		next if($me && ($person eq $me));

		my $xref = $person->{'xref'};
		next if($printed{$xref});

		# Gather the information on this person
		my $name = $person->name();

		$name =~ s/\///g;
		$nameparser->parse($name);
		my %name_components = $nameparser->components();
		my $firstname = $name_components{'given_name_1'};
		my $lastname = $name_components{'surname_1'};

		my $dob;
		eval {
			$dob = $person->get_value('birth date');
		};
		if($@) {
			warn "Can't parse record for $firstname $lastname";
			next;
		}

		next if($onlybirthdays && !defined($dob));

		my $dod = $person->get_value('death date') || $person->get_value('burial date');

		next if($onlydeaths && !defined($dod));

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			$yod = $1;
		}

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			$yob = $1;
		} elsif($dob) {
			if($opts{'w'} && !$warned{$person}) {
				if($opts{'f'}) {
					die $person->name(), ": invalid date of birth $dob\n";
				}
				warn $person->name(), ": invalid date of birth $dob\n";
				$warned{$person} = 1;
			}
			$yob = undef;
		} else {
			$yob = $dob;
		}

		if((!defined($opts{l})) && (!defined($yod)) && defined($yob) && ($yob > 1900)) {
			# Assuming living if we don't have a date of death and
			# they were born after 1900
			next;
		}

		unless($dob || $dod || $opts{a}) {
			next;
		}

		print 'Checking ', $person->as_string({ include_years => 1 }), "\n" if($opts{'v'});

		my $print = 0;
		my $aob;
		my $aod;

		if($dob && ($dob !~ /^\d{4}$/)) {
			my @btime = strptime($dob . ' 12:00');
			if(defined($btime[3]) && ($btime[3] == $day) && ($btime[4] == $month) && $btime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aob = (localtime)[5] - $btime[5];
					if($aob <= 0) {
						$aob += 1900;
					}
				}
			}
		}
		next if($onlybirthdays && !defined($aob));

		if($dod && ($dod !~ /^\d{4}$/)) {
			my @dtime = strptime($dod . ' 12:00');
			if(defined($dtime[3]) && ($dtime[3] == $day) && ($dtime[4] == $month) && $dtime[5]) {
				$print = 1;
				if(!$opts{a}) {
					$aod = (localtime)[5] - $dtime[5];
					if($aod <= 0) {
						$aod += 1900;
					}
				}
			}
		}
		next if($onlydeaths && !defined($aod));

		next unless($print or ($day == -1));

		if($opts{'w'} && (!$person->fams()) && (!$person->siblings()) && (!$person->mother()) && (!$person->father()) && (!$person->spouse())) {
			if($opts{'f'}) {
				die $person->as_string() . ': not connected to the tree';
			}
			red_warning({ person => $person, warning => 'not connected to the tree' });
		}

		print $person->as_string({
			include_years => 1,
			nee => 1,
			middle_names => 1,
		}), "\n";

		# Change surname of a married woman
		my $sex = $person->get_value('sex');
		my $maidenname;
		if(defined($sex) && ($sex eq 'F')) {
			my $husband = $person->husband();
			if(defined($husband)) {
				my $hname = $husband->name();
				if($hname =~ /(.+)\s*Jr\.?/i) {
					$hname = $1;
				}
				if($hname =~ /(.+)Mc\s+(.+)/) {
					$hname = "$1$2";
				}
				# print $person->name(), " married to $hname\n";
				if($hname =~ /^.+\s+\/(.+)\/$/) {
					$maidenname = $lastname;
					$lastname = lc($1);
				}
			}
		}

		$printed{$xref} = 1;

		my @spouses = $person->spouse();
		my $birth = $person->get_record('birth');
		my $death = $person->get_record('death');
		my $printed_death_year;
		my $end_of_sentence;
		my $printed_birth_year;
		my $birth_dt;
		my $death_dt;
		my $mother;
		my $father;
		my $dom;

		if($opts{d}) {
			# my $first_name = (split(/ /, $person->given_names()))[0];
			my $first_name;
			if($firstname) {
				$first_name = ucfirst($firstname);
				$first_name =~ s/\s.+//;
			}
			my $printed_first_name;
			my $printed_comma;
			my $any_output;
			my $space_count;
			my $printed_spouse_name;

			if(!$opts{a}) {
				if($me) {
					my $relationship = $me->relationship($person);
					if($relationship) {
						print "\tYour $relationship $first_name";
						my @occupations = $person->get_value('occupation');
						# TODO: print all occupations
						if($occupations[0]) {
							print ' (a';
							if($occupations[0] =~ /^[aeiou]/i) {
								print 'n';
							}
							print ' ', lc($occupations[0]), ')';
						}
						$any_output = 1;
						$printed_first_name = 1;
					} elsif($spouses[0]) {
						# FIXME: go through all the spouses until we find
						# the right one - perhaps using surname
						$relationship = $me->relationship($spouses[0]);
						if($relationship) {
							print "\t$first_name";
							my @occupations = $person->get_value('occupation');
							# TODO: print all occupations
							if($occupations[0]) {
								print ' (a';
								if($occupations[0] =~ /^[aeiou]/i) {
									print 'n';
								}
								print ' ', lc($occupations[0]), ')';
							}
							print ', the ',
								(($sex eq 'F') ? 'wife of' : 'husband of'),
								" your $relationship ",
								$spouses[0]->given_names(), ',';
							$printed_first_name = 1;
							$any_output = 1;
							$printed_comma = 1;
							$printed_spouse_name = 1;
						}
					}
				}

				if($aob || $aod) {
					unless($any_output) {
						print "\t$first_name";
						$any_output = 1;
						$printed_first_name = 1;
						my @occupations = $person->get_value('occupation');
						# TODO: print all occupations
						if($occupations[0]) {
							print ' (a';
							if($occupations[0] =~ /^[aeiou]/i) {
								print 'n';
							}
							print ' ', lc($occupations[0]), ')';
						}
					}
				}
				if($aob && $aod) {
					print " was born $aob years ago and died $dod years ago today";
					$printed_birth_year = 1;
				} elsif($aob) {
					print " was born $aob years ago today";
					$printed_birth_year = 1;
				} elsif($aod) {
					print " died $aod ", ($aod == 1) ? 'year' : 'years', ' ago today';
					$printed_death_year = 1;
				}
			} else {
				my @occupations = $person->get_value('occupation');
				# TODO: print all occupations
				if($occupations[0]) {
					if(defined($first_name)) {
						print $first_name;
					} else {
						print $person->pronoun();
					}

					print ' (a';
					if($occupations[0] =~ /^[aeiou]/i) {
						print 'n';
					}
					print ' ', lc($occupations[0]), ')';
					$any_output = 1;
					$printed_first_name = 1;
				}

				if($me) {
					my $relationship = $me->relationship($person);
					if($relationship) {
						if($relationship) {
							if(!$printed_first_name) {
								if(defined($first_name)) {
									print $first_name;
								} else {
									print $person->pronoun();
								}
								$printed_first_name = 1;
								$any_output = 1;
							}
							print ", your $relationship,";
							$any_output = 1;
							$printed_first_name = 1;
						} elsif($spouses[0]) {
							$relationship = $me->relationship($spouses[0]);
							if($relationship) {
								if(!$printed_first_name) {
									print $first_name;
									$printed_first_name = 1;
									$any_output = 1;
								}
								print ', the';
								print ' ', (($sex eq 'F') ? 'wife of' : 'husband of'), " your $relationship,";
								$printed_first_name = 1;
								$any_output = 1;
								$printed_comma = 1;
							}
						}
					}
				}
				if($dob) {
					if(!$printed_first_name) {
						if(defined($first_name)) {
							print $first_name;
						} else {
							print $person->pronoun();
						}
						$any_output = 1;
						$printed_first_name = 1;
					}
					print ' was born', year(person => $person, string => $dob);
					$printed_birth_year = 1;
				}
				$printed_first_name = 1;
			}
			my $pob;
			if($birth && $birth->place()) {
				$pob = $birth->place();
			}
			if($printed_birth_year && defined($pob)) {
				print place(person => $person, place => $pob);
				$any_output = 1;
			} elsif($printed_death_year) {
				my $pod = place(person => $person, record => $death);
				if($pod) {
					print $pod;
					$any_output = 1;
				}
			}
			if($birth && !$printed_birth_year && ($pob || $dob)) {
				# print ' having been born';
				if(!$any_output) {
					if(defined($first_name)) {
						print $first_name;
					} else {
						print $person->pronoun();
					}
					$printed_first_name = 1;
				}
				print ' was born';
				if(defined($pob)) {
					if($death && $any_output) {
						my $pod = $death->place();
						if($pod && ($pob eq $pod)) {
							print ' there';
						} else {
							print place({ person => $person, place => $pob });
						}
					} else {
						print place({ person => $person, place => $pob });
					}
				}
				$any_output = 1;
				if(defined($dob)) {
					print year(person => $person, string => $dob);
				} else {
					$dob = $person->get_value('baptism date');
					if($dob) {
						# Use the baptism date for approximation
						if($dob =~ /(\d{4})$/) {
							print " around $1";
						} else {
							print " around $dob";
						}
					}
				}
				$any_output = 1;
			}
			if($any_output) {
				print '.  ';
				$space_count = 2;
				$any_output = 1;
				$end_of_sentence = 1;
			}

			my @father = $person->father();
			$father = $father[0];
			my @mother = $person->mother();
			$mother = $mother[0];
			if($dob && ($dob !~ /^\d{4}$/) && ($dob =~ /^\d/)) {
				my $d;
				eval {
					$d = $date_parser->parse_date_value(date => $dob);
				};
				if($d) {
					$birth_dt = $d->{one_date};
				}
			}
			if($father || $mother) {
				if(!$any_output) {
					print $first_name;
				} else {
					print ' ' if(!$space_count);
					print $person->pronoun();
				}
				if((!$opts{'l'}) || $person->death() || (!defined($yob)) || ($yob <= 1900)) {
					print ' was the ';
				} else {
					print ' is the ';
				}
				if($birth_dt) {
					my @siblings = $person->siblings();
					if(scalar(@siblings)) {
						my $count = 1;
						my $fail = 0;
						foreach my $sibling(@siblings) {
							my $dob = $sibling->get_value('birth date');
							if($dob) {
								my $d;
								eval {
									$d = $date_parser->parse_date_value(date => $dob);
								};
								if($d) {
									$d = $d->{one_date};
									$count++ if($d && ($d < $birth_dt));
								} else {
									$fail = 1;
									last;
								}
							}
						}
						if($fail) {
							print 'child';
						} else {
							if($count == (scalar(@siblings) + 1)) {
								print 'last';
							} else {
								print ordinate($count);
							}
							print ' of ', scalar(@siblings) + 1, ' children';
						}
					} else {
						# print ' only child of';
						print 'child';
					}
				} else {
					print 'child';
				}

				print ' of';

				if($father) {
					print ' ', $father->as_string();
					my @occupations = $father->get_value('occupation');
					# TODO: print all occupations
					if($occupations[0]) {
						print ' (a';
						if($occupations[0] =~ /^[aeiou]/i) {
							print 'n';
						}
						print ' ', lc($occupations[0]), ')';
					}
					if($mother) {
						print ' and';
					}
				}
				if($mother) {
					print ' ', $mother->as_string({ give_maidenname => 0 });
					my @occupations = $mother->get_value('occupation');
					# TODO: print all occupations
					if($occupations[0]) {
						print ' (a';
						if($occupations[0] =~ /^[aeiou]/i) {
							print 'n';
						}
						print ' ', lc($occupations[0]), ')';
					}
				}
				$end_of_sentence = 0;
				$any_output = 1;
			}
			# TODO: $person->marriage_count()
			if($spouses[0]) {
				if($end_of_sentence) {
					print $person->pronoun();
				} elsif(($dod && (!$aod)) || $person->get_value('baptism date')) {
					if($any_output) {
						if(((scalar(@spouses) == 1) && !$aod) || $dod) {
							print ',';
						} else {
							print ' and';
						}
					} elsif(defined($first_name)) {
						print $first_name;
					} else {
						print $person->pronoun();
					}
				} elsif($any_output) {
					print ',';
					if(($dod && (!$aod)) || $person->get_value('baptism date')) {
						print ' and';
					}
				} elsif(defined($first_name)) {
					print $first_name;
				} else {
					print $person->pronoun();
				}
				my $marriage = $person->get_record('marriage') || $spouses[0]->get_record('marriage') || $person->get_record('fams marriage');
				if($marriage) {
					$dom = $marriage->date() || $person->get_value('marriage date') || $spouses[0]->get_value('marriage date');
				}
				if((!$opts{l}) || $dod || $dom || ($yob && ($yob <= 1900)) || $person->get_value('burial date')) {
					print ' was';
				} else {
					print ' is';
				}
				print ' married ';
				if(scalar(@spouses) == 1) {
					print 'to ', $spouses[0]->as_string();
					print year(person => $person, string => $dom, must_postdate => $birth_dt) if($dom);
					my $pom = $person->get_value('marriage place');
					if((!defined($pom)) && defined($marriage)) {
						$pom = $marriage->place();
					}
					print place(place => $pom, person => $person) if($pom);
					$end_of_sentence = 0;
				} else {
					if(scalar(@spouses) == 2) {
						print 'twice';
					} else {
						print scalar(@spouses), ' times';
					}
					my $names = join(', ', map { $_->as_string() } @spouses);
					substr($names, rindex($names, ', '), 2, ' and ');
					print ", to $names";
					# TODO: print the date and places of the marriages
					if((defined($dod)) && $aod) {
						print ".  ";
						$end_of_sentence = 1;
					}
				}
			}
		} elsif(defined($dob) && (!$onlydeaths) && !$onlybirthdays) {
			my $d;
			if(($dob !~ /^\d{4}$/) && ($dob =~ /^\d/)) {
				eval {
					$d = $date_parser->parse_date_value(date => $dob);
				};
			}
			if($d) {
				$birth_dt = $d->{one_date};
				print "\tBorn: ", $birth_dt->strftime('%x');
			} else {
				if($@) {
					if($opts{'f'}) {
						die $@;
					}
					if($opts{'w'}) {
						red_warning({ person => $person, warning => $@ });
					}
				}
				print "\tBorn: $dob";
			}
			print "\n" if(defined($dod));
		}
		my $just_printed_death = 0;
		if(defined($dod) && (!$onlydeaths) && !$onlybirthdays) {
			if($opts{d}) {
				if($aod) {
					if($death && !$printed_death_year) {
						my $pod = $death->place();
						if($pod) {
							if($end_of_sentence) {
								print $person->pronoun();
							} else {
								print ' and';
							}
							print " died in $pod";
							validate_place(person => $person, place => $pod);
							$end_of_sentence = 0;
						}
					}
				} else {
					if($mother || $father || ($spouses[0] && !$end_of_sentence)) {
						if($end_of_sentence) {
							print $person->pronoun();
						} else {
							print ',' if($spouses[0]);
							print ' and' if($spouses[0] || ($father && $mother));
						}
						print ' died';
					} else {
						print '.  ' if(!$end_of_sentence);
						print $person->pronoun(), ' died';
					}
					if(!$person->get_value('death date')) {
						# Use the burial date for approximation
						if($dod =~ /(\d{4})$/) {
							print " around $1";
						} else {
							print " around $dod";
						}
					} else {
						print year(person => $person, string => $dod);
					}
					print place(record => $death, person => $person);
					$just_printed_death = 1;
					$end_of_sentence = 0;
				}
			} else {
				my $d;
				if(($dod !~ /^\d{4}$/) && ($dod =~ /^\d/)) {
					eval {
						$d = $date_parser->parse_date_value(date => $dod);
					};
				}
				if($d) {
					$death_dt = $d->{one_date};
					print "\tDied: ", $death_dt->strftime('%x');
				} else {
					if($@) {
						if($opts{'f'}) {
							die $@;
						}
						if($opts{'w'}) {
							red_warning({ person => $person, warning => $@ });
						}
					}
					print "\tDied: $dod";
				}
			}
		}
		if($opts{'w'} && defined($yob) && defined($yod) && (($yod - $yob) > 120)) {
			if($opts{'f'}) {
				die $person->as_string() . ': age at death too large';
			}
			red_warning({ person => $person, warning => 'age at death too large' });
		}
		if($opts{'d'}) {
			my $baptism = $person->get_record('baptism');
			my $dobaptism;
			if($baptism) {
				$dobaptism = $baptism->date();
			}
			if(!defined($dobaptism)) {
				$dobaptism = $person->get_value('baptism date');
			}
			my $just_printed_baptism = 0;
			if($dobaptism) {
				if($dod) {
					print '.  ' if(!$end_of_sentence);
					print $person->pronoun();
				} else {
					print ' and';
				}
				print ' was';
				if($baptism && $baptism->place() && $death && $death->place() && ($baptism->place() eq $death->place())) {
					print ' also';
				}
				if($ENV{'LANG'} =~ /^en_US/) {
					print ' baptized';
				} else {
					print ' baptised';
				}
				if($baptism) {
					my $pob = $baptism->place();
					if($pob) {
						if((!$dod) && $pob && $birth && $birth->place() && ($pob eq $birth->place())) {
							print ' there';
						} else {
							print place({ person => $person, place => $pob });
						}
					}
					print year(string => $dobaptism, person => $person, must_postdate => $birth_dt);
				} else {
					print " on $dobaptism";
				}
				$end_of_sentence = 0;
				$just_printed_death = 0;
				$just_printed_baptism = 1;
			}
			my $burial = $person->get_record('burial');
			my $doburial;
			if($burial) {
				$doburial = $burial->date();
			}
			if(!$doburial) {
				$doburial = $person->get_value('burial date');
			}
			my $poburial;
			if($burial) {
				$poburial = $burial->place();
			}
			if(!$poburial) {
				$poburial = $person->get_value('burial place');
			}
			if($doburial || $poburial) {
				# FIXME: This entire block is complex
				if($just_printed_death && (!$end_of_sentence) && $poburial and $death && $death->place() && ($poburial eq $death->place()) && !$burial->date()) {
					print ' where ', lcfirst($person->pronoun()), ' is buried';
				} else {
					if((!$just_printed_death) && (!$end_of_sentence) && $baptism) {
						print ' and ';
					} elsif((($dobaptism || $spouses[0]) && (!$dom) && !$dod) ||
					   ((!$dobaptism) && $death && $death->place() && $poburial && ($poburial eq $death->place()))) {
						print ' and ';
						if($just_printed_death && ((!defined($baptism)) || !defined($baptism->place()))) {
							if($burial->date()) {
								print 'was ';
							} else {
								print 'is ';
							}
						}
					} else {
						print '.  ' if(!$end_of_sentence);
						print $person->pronoun();
						if($burial->date()) {
							print ' was ';
						} else {
							print ' is ';
						}
					}
					print 'buried';
					if($poburial) {
						if(($baptism && $baptism->place() && ($poburial eq $baptism->place())) ||
						   ((!$baptism) && $death && $death->place() && ($poburial eq $death->place()))) {
							print ' there';
						} else {
							print place({ person => $person, place => $poburial });
						}
						$just_printed_death = 1;
					}
					if($doburial) {
						print year(person => $person, string => $burial->date(), must_validate => $death_dt);
					}
				}
				print '. ';
				$end_of_sentence = 1;
				$just_printed_baptism = 0;
			}
			my $family = $person->fams();
			if((defined($family)) && $family->number_of_children()) {
				if((!$just_printed_death) && (!$just_printed_baptism)) {
					if($end_of_sentence) {
						print $person->pronoun();
					} else {
						print ' with whom ', lcfirst($person->pronoun());
					}
				} else {
					print '. ' if(!$end_of_sentence);
					print ' ', $person->pronoun();
				}
				my $child_count = $family->number_of_children();
				my $all_alive = 1;
				if($yob && ($year >= $yob + 150)) {
					$all_alive = 0;
				} else {
					foreach my $child($family->children()) {
						if($child->get_record('death')) {
							$all_alive = 0;
							last;
						}
						if($child->get_record('burial')) {
							$all_alive = 0;
							last;
						}
						my $dob = $child->get_value('birth date');
						if($dob) {
							if(($dob =~ /^\d{4}$/) && ($dob < ($year - 100))) {
								$all_alive = 0;
								last;
							}
							if($dob =~ /^\d/) {
								my $d;
								eval {
									$d = $date_parser->parse_date_value(date => $dob);
								};
								if($d && ($d->{one_date}->strftime('%Y') < ($year - 120))) {
									$all_alive = 0;
									last;
								}
							}
						}
					}
				}

				if($all_alive) {
					print ' has ';
				} elsif((!$opts{'l'}) || ($yob && ($year > $yob + 100))) {
					print ' had ';
				} else {
					print $dod ? ' had ' : ' has ';
				}

				if($child_count == 1) {
					if($all_alive) {
						print 'one surviving child, ';
					} else {
						print 'one child, ';
					}
					print $family->children()->given_names();
				} else {
					if($all_alive) {
						print "$child_count surviving children, ";
					} else {
						print "$child_count children, ";
					}

					my $children = join(', ', map { $_->given_names() } $family->children());
					substr($children, rindex($children, ', '), 2, ' and ');
					print $children;
				}
				print ".\n";
				foreach my $child($family->children()) {
					my $dob = $child->get_value('birth date');
					if($dob) {
						print "\t" unless($opts{'a'});
						print "\t", $child->given_names(), ' was born ';
						if($dob =~ /^Abt\.?\s*(.+)/i) {
							print "around $1";
						} elsif(($dob =~ /^\d{4}$/) || ($dob !~ /^\d/)) {
							print "in $dob";
						} else {
							my $d;
							eval {
								$d = $date_parser->parse_date_value(date => $dob);
							};
							if($d) {
								$d = $d->{one_date};
								print 'on ', $d->strftime('%x');
								if($opts{'w'}) {
									if($birth_dt && ($d <= $birth_dt)) {
										if($opts{'f'}) {
											die $child->name(), ': Born before parent was born';
										}
										red_warning({ person => $child, warning => 'born before parent was born' });
									}
									# Fix me, it's OK to be born a few
									# months after the father's death
									if($death_dt && ($d > $death_dt)) {
										if($opts{'f'}) {
											die $child->name(), ': Born after parent died';
										}
										red_warning({ person => $child, warning => 'born after parent died' });
									}
								}
							} else {
								if($@) {
									# RT 107354
									chomp $@;
									if($opts{'f'}) {
										die $child->as_string() . ": $@";
									}
									if($opts{'w'}) {
										red_warning({ person => $child, warning => $@ });
									}
								}
							}
						}
						print ".\n";
					} elsif($child->get_value('baptism date')) {
						print "\t" unless($opts{'a'});
						print "\t", $child->given_names(),
							' was born c',
							$child->get_value('baptism date'),
							".\n";
					}
				}
			} else {
				print '.' if(!$end_of_sentence);
				print "\n";
			}
		}
		if($opts{'d'}) {
			if($person->get_value('note')) {
				print "Note: ", $person->get_value('note'), "\n";
			}
			if($opts{'a'}) {
				print '-' x 80;
			}
		}
		print "\n" unless($onlybirthdays || $onlydeaths);

		# Will be rewritten to be clearer
		if(0) {
		print $person->as_string({
			include_years => 1,
			nee => 1,
			middle_names => 1,
		}), "\n";
		if($opts{'d'}) {
			my $birth = $person->get_record('birth');
			my $dateofbirth = $person->get_value('birth date');
			if((!$dateofbirth) && $birth) {
				$dateofbirth = $birth->date();
			}
			my $placeofbirth = $person->get_value('birth place');
			if((!$placeofbirth) && $birth) {
				$placeofbirth = $birth->place();
			}

			my $baptism = $person->get_record('baptism');
			my $dateofbaptism = $person->get_value('baptism date');
			if((!$dateofbaptism) && $baptism) {
				$dateofbaptism = $baptism->date();
			}
			my $placeofbaptism = $person->get_value('baptism place');
			if((!$placeofbaptism) && $baptism) {
				$placeofbaptism = $baptism->place();
			}

			my $marriage = $person->get_record('marriage') || $person->get_record('fams marriage');
			if((!defined($marriage)) && scalar(@spouses)) {
				$spouses[0]->get_record('marriage');
			}
			my $dateofmarriage = $person->get_value('marriage date');
			if((!$dateofmarriage) && $marriage) {
				$dateofmarriage = $marriage->date();
			}
			my $placeofmarriage = $person->get_value('marriage place');
			if((!$placeofmarriage) && $marriage) {
				$placeofmarriage = $marriage->place();
			}

			my $death = $person->get_record('death');
			my $dateofdeath = $person->get_value('death date');
			if((!$dateofdeath) && $death) {
				$dateofdeath = $death->date();
			}
			my $placeofdeath = $person->get_value('death place');
			if((!$placeofdeath) && $death) {
				$placeofdeath = $death->place();
			}

			my $burial = $person->get_record('burial');
			my $dateofburial = $person->get_value('burial date');
			if((!$dateofburial) && $burial) {
				$dateofburial = $burial->date();
			}

			my $pronoun = $person->pronoun();
			my $sex = $person->sex();
			my @spouses = $person->spouse();
			my $family = $person->fams();
			my @children;
			my $numberofchildren = 0;
			if($family) {
				$numberofchildren = $family->number_of_children();
				@children = $family->children();
			}

			my $relationship;
			my $spouserelationship;
			my $spouse;
			if($me) {
				$relationship = $me->relationship($person);
				if((!$relationship) && scalar(@spouses)) {
					foreach my $s(@spouses) {
						$spouserelationship = $me->relationship($s);
						if($spouserelationship) {
							$spouse = $s;
							last;
						}
					}
				}
			}
			print "\t";
			if($relationship) {
				print "Your $relationship ";
				print $firstname if($firstname);
			} elsif($spouserelationship) {
				print "$firstname, the " if($firstname);
				if($sex eq 'F') {
					print 'wife';
				} else {
					print 'husband';
				}
				print " of your $spouserelationship ", $spouse->as_string(), ',';
			} elsif($firstname) {
				print $firstname;
			} else {
				print $pronoun;
			}
			if($aob && $aod) {
				print " was born $aob years ago and died $dod years ago today.";
			} elsif($aob) {
				print " was born $aob ", ($aob == 1) ? 'year' : 'years', ' ago today';
				if($placeofbirth) {
					print place({ person => $person, place => $placeofbirth });
				}
				print '.';
			} elsif($aod) {
				print " died $aod ", ($aod == 1) ? 'year' : 'years', ' ago today';
				if($placeofdeath) {
					print place({ person => $person, place => $placeofdeath });
				}
				print '.';
			}

			my $printed_birth_information = 0;
			if((!$aob) && ($dateofbirth || $dateofbaptism || $placeofbirth || $placeofbaptism)) {
				print " $pronoun";
				if($dateofbirth || $placeofbirth) {
					print ' was born';
					if($placeofbirth) {
						print place({ person => $person, place => $placeofbirth });
					}
					if($dateofbirth) {
						print year({ person => $person, date => $dateofbirth });
					}
					if($dateofbaptism || $placeofbaptism) {
						print ' and';
					}
				}
				if($dateofbaptism || $placeofbaptism) {
					unless($dateofbirth || $placeofbirth) {
						print ' was ';
					}
					if($ENV{'LANG'} =~ /^en_US/) {
						print 'baptized';
					} else {
						print 'baptised';
					}
					if($placeofbaptism) {
						print place({ person => $person, place => $placeofbaptism });
					}
					if($dateofbaptism) {
						print year({ person => $person, date => $dateofbaptism });
					}
				}
				if(scalar(@spouses)) {
					print ' and';
				} else {
					print '.';
				}
				$printed_birth_information = 1;
			}

			if(scalar(@spouses)) {
				print " $pronoun" if(!$printed_birth_information);

				if(scalar(@spouses) == 1) {
					if($placeofmarriage || $dateofmarriage) {
						print ' married ';
					} else {
						print ' was married to ';
					}
					print $spouses[0]->as_string();
					print year(person => $person, string => $dateofmarriage, must_postdate => $birth_dt) if($dateofmarriage);
					print place(place => $placeofmarriage, person => $person) if($placeofmarriage);
					$end_of_sentence = 0;
				} else {
					print ' was married ';
					if(scalar(@spouses) == 2) {
						print 'twice';
					} else {
						print scalar(@spouses), ' times';
					}
					my $names = join(', ', map { $_->as_string() } @spouses);
					substr($names, rindex($names, ', '), 2, ' and ');
					print ", to $names";
					# TODO: print the date and places of the marriages
				}
				if($numberofchildren) {
					print ' with whom ', lcfirst($pronoun), ' had ',
						($numberofchildren == 1) ? '1 child, ' : "$numberofchildren children, ";
				}
			} elsif($numberofchildren) {
				print " $pronoun had ",
					($numberofchildren == 1) ? '1 child, ' : "$numberofchildren children, ";
			}
			if($numberofchildren == 1) {
				print $children[0]->given_names();
			} elsif($numberofchildren > 1) {
				my $childnames = join(', ', map { $_->given_names() } @children);
				substr($childnames, rindex($childnames, ', '), 2, ' and ');
				print $childnames;
			}
			print ".\n";
		}
		}
	}
}

sub Gedcom::Individual::as_string
{
	my $self = shift;
	my %args = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $name = $self->name();

	$name =~ s/\///g;
	$nameparser->parse($name);

	my %name_components = $nameparser->components();
	my $first_name = $name_components{'given_name_1'};
	my $middle_name = $name_components{'middle_name'};
	my $surname = $name_components{'surname_1'} || $self->surname();
	my $suffix = $name_components{'suffix'};

	my $has_maiden_name;
	if($args{'nee'}) {
		my $sex = $self->get_value('sex');
		if(defined($sex) && ($sex eq 'F')) {
			my $husband = $self->husband();
			if(defined($husband)) {
				$surname = $husband->surname();
				$has_maiden_name = 1;
			}
		}
	}

	my $rc = $first_name;
	if($args{'middle_names'} && $middle_name) {
		$rc .= " $middle_name";
	}

	if($surname) {
		if($rc) {
			$rc .= ' ';
		}
		$rc .= normalize_name($surname);
		if($suffix) {
			$rc .= " $suffix";
		}
	}

	if($has_maiden_name && $self->surname()) {
		$rc .= ' (nee ' . normalize_name($self->surname()) . ')';
	}

	if(!defined($rc)) {
		if($opts{'f'}) {
			die "Can't determine name of this person";
		}
		if($opts{'w'}) {
			red_warning({ warning => "Can't determine name of this person" });
			$args{'include_years'} = 1;
			$rc = 'Unknown person ';
		}
	}
	if($args{'include_years'}) {
		my $dob = $self->get_value('birth date');

		my $yob;	# Year of birth
		if($dob && ($dob =~ /.*?(\d{3,4})/)) {
			if($dob =~ /^(Abt|ca?)\.?\s*(.+)/i) {
				$yob = "c$2";
			} else {
				$yob = $1;
			}
		} else {
			$dob = $self->get_value('baptism date');
			if($dob && ($dob =~ /.*?(\d{3,4})/)) {
				$yob = "c$1";
			}
		}

		my $dod = $self->get_value('death date');

		my $yod;	# Year of death
		if($dod && ($dod =~ /.*?(\d{3,4})/)) {
			$yod = $1;
		} else {
			$dod = $self->get_value('burial date');
			if($dod && ($dod =~ /.*?(\d{3,4})/)) {
				$yod = "c$1";
			}
		}

		$rc .= ' ' if($yob || $yod);

		if($yob) {
			$rc .= $yob;
		}

		$rc .= ' -' if($yob || $yod);

		if($yod) {
			$rc .= " $yod";
		}
	}

	return $rc;
}

sub normalize_name
{
	# my $name = shift;

	# my $rc;
	# foreach my $word(split(/-| |'/, lc($name))) {
		# $rc .= '-' if($rc && ($name =~ /-/));
		# $rc .= "'" if($rc && ($name =~ /'/));
		# $rc .= ' ' if($rc && ($name =~ / /));
		# $rc .= ucfirst($word);
	# }

	# return $rc;

	return Lingua::EN::NameCase::nc(shift);
}

sub Gedcom::Individual::pronoun
{
	my $self = shift;

	my $sex = $self->get_value('sex');

	if(defined($sex)) {
		if($sex eq 'F') {
			return 'She';
		}
		if($sex eq 'M') {
			return 'He';
		}
	}
	return 'They';
}

# FIXME: currently only finds ancestors
# TODO: find in-laws
# See http://www.myrelative.com/html/relationship.html for inspiration
sub Gedcom::Individual::relationship
{
	my $self = shift;
	my $other = shift;

	my @ancestors1 = $self->ancestors();
	return unless @ancestors1;

	my $sex = $other->get_value('sex');
	if((!defined($sex)) || ($sex !~ /[MF]/)) {
		if($opts{'f'}) {
			die "\n", $other->as_string(), ": unknown sex\n";
		}
		if($opts{'w'}) {
			red_warning({ person => $other, warning => 'unknown sex' });
		}
		return;
	}

	foreach my $person1(@ancestors1) {
		if($person1 eq $other) {
			# Direct ancestor
			my $steps = stepsabove($self, $other, 0);
			my $title = ($sex eq 'M') ? 'father' : 'mother';
			if($steps >= 5) {
				$steps -= 2;
				return "$steps times great-grand$title";
			} elsif($steps == 1) {
				return $title;
			} elsif($steps == 2) {
				return "grand$title";
			} elsif($steps == 3) {
				return "great-grand$title";
			} elsif($steps == 4) {
				return "great-great-grand$title";
			} elsif($steps <= 0) {
				if($opts{'f'}) {
					die $other->as_string(), ": BUG - not a direct ancestor, steps = $steps";
				} else {
					warn colored($other->as_string() . ": BUG - not a direct ancestor, steps = $steps", 'red');
				}
			}
		}
	}

	my @ancestors2 = $other->ancestors();
	return unless(@ancestors2);

	my $p1level = 0;
	foreach my $person1(@ancestors1) {
		my $p2level = 0;
		foreach my $person2(@ancestors2) {
			# print $person1->as_string(), '->', $person2->as_string(), "\n";
			# G::C is noisy
			# my $c = Gedcom::Comparison->new($person1, $person2);
			# if($c->identical($person2)) {
				# die 'match found';
			# }
			if($person1 eq $person2) {
				# Common ancestor is $person2
				my $steps1 = stepsabove($self, $person1, 0);
				return if($steps1 > 7);
				my $steps2 = stepsabove($other, $person2, 0);
				return if($steps2 > 7);

				# It would be nice to do this as an algorithm, but this will do
				# e.g. 2, 1 is uncle
				my %male_relationships = (
					1 << 8 | 1 => 'brother',
					2 << 8 | 1 => 'uncle',
					3 << 8 | 1 => 'great-uncle',
					4 << 8 | 1 => 'great-great-uncle',
					2 << 2 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					3 << 8 | 2 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					4 << 8 | 2 => 'first cousin twice-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 4 => 'second cousin once-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
				);
				my %female_relationships = (
					1 << 8 | 1 => 'sister',
					2 << 8 | 1 => 'aunt',
					3 << 8 | 1 => 'great-aunt',
					4 << 8 | 1 => 'great-great-aunt',
					2 << 2 | 2 => 'cousin',
					2 << 8 | 3 => 'first cousin once-removed',
					3 << 8 | 2 => 'first cousin once-removed',
					2 << 8 | 4 => 'first cousin twice-removed',
					4 << 8 | 2 => 'first cousin twice-removed',
					3 << 8 | 3 => 'second cousin',
					3 << 8 | 4 => 'second cousin once-removed',
					6 << 8 | 4 => 'third cousin twice-removed',
				);

				my $rc = ($sex eq 'M') ?
					$male_relationships{($steps1 << 8) | $steps2} :
					$female_relationships{($steps1 << 8) | $steps2};
				# print "$steps1, $steps2\n" unless($rc);
				return $rc;
			}
		}
	}
}

sub stepsabove
{
	my $person = shift;
	my $target = shift;
	my $count = shift;

	return -1 if($count == -1);

	if($person eq $target) {
		return $count;
	}
	my @father = $person->father();
	my $father = $father[0];
	my @mother = $person->mother();
	my $mother = $mother[0];

	if($father) {
		my $rc = stepsabove($father, $target, $count + 1);
		return $rc if($rc != -1);
	}
	if($mother) {
		return stepsabove($mother, $target, $count + 1);
	}
	return -1;
}

sub year
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $string = $params{'string'} || $params{'date'};

	if(!defined($string)) {
		$string = $params{'record'};
		return unless($string);

		$string = $string->date();
		return unless($string);
	}

	if($string =~ /^\d{4}$/) {
		return " in $string";
	}
	if($string =~ /^(Abt|ca?)\.?\s*(.+)/i) {
		return " c$2";
	}
	if($string =~ /^\d/) {
		my $person = $params{'person'};
		my $d;
		eval {
			$d = $date_parser->parse_date_value(date => $string);
		};
		if($d) {
			$d = $d->{one_date};
			my $must_postdate = $params{'must_postdate'};
			if($must_postdate) {
				if($opts{'f'}) {
					die $person->as_string(), ": Something is wrong with the date $string which should be after ", $must_postdate->strftime('%x') if($d < $must_postdate);
				}
				if($opts{'w'}) {
					red_warning({ person => $person, warning => "something is wrong with the date $string which should be after " . $must_postdate->strftime('%x') }) if($d < $must_postdate);
				}
			}
			return ' on ', $d->strftime('%x');
		}
		if($@) {
			# RT 107354
			chomp $@;
			if($opts{'f'}) {
				if($person) {
					die $person->as_string() . ": $@";
				} else {
					die $@;
				}
			}
			if($opts{'w'}) {
				red_warning({ person => $person, warning => $@ });
			}
		}
		return " on $string";
	}
	if($string =~ /^bef.? (\d{4})/i) {
		return " before $1";
	}
	if($string =~ /^By (\d{4})/i) {
		my $person = $params{'person'};
		if($opts{'f'}) {
			if($person) {
				die $person->as_string() . " says 'By' instead of 'Bef'";
			} else {
				die "Got 'By' instead of 'Bef'";
			}
		}
		if($opts{'w'}) {
			if($person) {
				red_warning({ person => $person, warning => "says 'By' instead of 'Bef'" });
			} else {
				warn colored("Got 'By' instead of 'Bef'", 'red');
			}
		}
		return " before $1";
	}

	return " in $string";
}

sub place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	if(!defined($place)) {
		$place = $params{'record'};
		return unless($place);

		$place = $place->place();
		return unless($place);
	}

	validate_place({ person => $params{'person'}, place => $place });

	if($place =~ /^\d/) {
		return " at $place";
	}
	if($place eq 'USA') {
		return ' in the USA';
	}
	return " in $place";
}

sub validate_place
{
	my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

	my $place = $params{'place'};
	die 'place is not optional' unless $place;

	if($places{$place}) {
		return $places{$place};
	}

	# US and Canada are more logical, using city,county,state,country, than other countries
	if($opts{'w'} && (($place !~ /,.*,.*,.*/) || ($place =~ /USA|Canada/i))) {
		if($place =~ /(.*),\s*Independent Cities\s*(.*)/i) {
			$place = "$1$2";
		}
		if(!$geocoder->geocode($place)) {
			# Don't die because there are many
			# false positives as locations
			# may no longer exist
			my $person = $params{'person'};
			if($person) {
				warn colored($person->as_string({ include_dates => 1 }) . ": unknown location $place", 'red');
			} else {
				warn colored("Unknown location $place", 'red');
			}
			$places{$place} = 0;
			return 0;
		}
	}
	$places{$place} = 1;
	return 1;
}

sub red_warning
{
	if($opts{'w'}) {
		my %params = (ref($_[0]) eq 'HASH') ? %{$_[0]} : @_;

		if($params{'person'}) {
			warn colored($params{'person'}->as_string() . ': ' . $params{'warning'}, 'red');
		} else {
			warn colored($params{'warning'}, 'red');
		}
	}
}
